import {
  clear_text_content,
  clone_node,
  createClassComponent,
  delegate,
  empty,
  hydrate_anchor,
  hydrate_nodes,
  hydrating,
  set_class_name,
  set_hydrate_nodes,
  set_hydrating,
  set_should_intro,
  should_intro,
  stringify
} from "./chunk-N7LUUSXP.js";
import {
  AttributeAliases,
  BLOCK_EFFECT,
  DelegatedEvents,
  EACH_INDEX_REACTIVE,
  EACH_IS_ANIMATED,
  EACH_IS_CONTROLLED,
  EACH_IS_STRICT_EQUALS,
  EACH_ITEM_REACTIVE,
  EACH_KEYED,
  EFFECT_RAN,
  EFFECT_TRANSPARENT,
  HYDRATION_END,
  HYDRATION_END_ELSE,
  HYDRATION_START,
  INERT,
  LEGACY_DERIVED_PROP,
  LOADING_ATTR_SYMBOL,
  PROPS_IS_IMMUTABLE,
  PROPS_IS_LAZY_INITIAL,
  PROPS_IS_RUNES,
  PROPS_IS_UPDATED,
  STATE_SYMBOL,
  TEMPLATE_FRAGMENT,
  TEMPLATE_USE_IMPORT_NODE,
  TRANSITION_GLOBAL,
  TRANSITION_IN,
  TRANSITION_OUT,
  UNINITIALIZED,
  add_snippet_symbol,
  bind_invalid_checkbox_value,
  bind_invalid_export,
  bind_not_bindable,
  block,
  branch,
  component_api_changed,
  create_fragment_from_html,
  current_component_context,
  current_effect,
  deep_read_state,
  define_property,
  derived,
  derived_safe_equal,
  destroy_effect,
  dev_current_component_function,
  each_key_duplicate,
  effect,
  effect_root,
  flush_sync,
  get,
  get_component,
  get_descriptor,
  get_descriptors,
  get_prototype_of,
  get_proxied_value,
  hydration_attribute_changed,
  inspect_fn,
  is,
  is_array,
  is_frozen,
  is_function,
  is_signals_recorded,
  map_get,
  map_set,
  mutable_source,
  namespace_svg,
  object_keys,
  pause_children,
  pause_effect,
  props_invalid_value,
  props_rest_readonly,
  queue_task,
  remove,
  render_effect,
  resume_effect,
  run_out_transitions,
  safe_equals,
  safe_not_equal,
  set,
  set_current_component_context,
  set_current_effect,
  set_current_reaction,
  set_dev_current_component_function,
  source,
  svelte_component_invalid_this_value,
  untrack,
  update,
  user_effect,
  user_pre_effect
} from "./chunk-O56VML7M.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";
import {
  loop,
  raf
} from "./chunk-PMCBTWW3.js";
import {
  subscribe_to_store
} from "./chunk-5OAVULKH.js";
import {
  is_promise,
  noop,
  run,
  run_all
} from "./chunk-YWUGNIHA.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-AXYXVOZD.js";

// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    const nodes = hydrating ? is_array(dom) ? dom : [dom] : dom.nodeType === 11 ? Array.from(dom.childNodes) : [dom];
    assign_locations(nodes, filename, locations);
    return dom;
  };
}
function assign_location(element2, filename, location) {
  element2.__svelte_meta = {
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(
      /** @type {import('#client').TemplateNode[]} */
      Array.from(element2.childNodes),
      filename,
      location[2]
    );
  }
}
function assign_locations(nodes, filename, locations) {
  var j = 0;
  var depth = 0;
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    if (hydrating && node.nodeType === 8) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START)
        depth += 1;
      if (comment2.data.startsWith(HYDRATION_END))
        depth -= 1;
    }
    if (depth === 0 && node.nodeType === 1) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[j++]
      );
    }
  }
}

// node_modules/svelte/src/internal/client/dev/hmr.js
function hmr(source2) {
  return (anchor, props) => {
    let instance = {};
    let effect2;
    block(() => {
      const component2 = get(source2);
      if (effect2) {
        for (var k in instance)
          delete instance[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        set_should_intro(false);
        Object.defineProperties(
          instance,
          Object.getOwnPropertyDescriptors(component2(anchor, props))
        );
        set_should_intro(true);
      });
    });
    return instance;
  };
}

// node_modules/svelte/src/internal/client/dev/legacy.js
function legacy_api() {
  var _a;
  const component2 = (_a = current_component_context) == null ? void 0 : _a.function;
  function error(method) {
    var _a2;
    const parent = ((_a2 = get_component()) == null ? void 0 : _a2.filename) ?? "Something";
    component_api_changed(parent, method, component2.filename);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/await.js
function await_block(anchor, get_input, pending_fn, then_fn, catch_fn) {
  const component_context = current_component_context;
  let component_function;
  if (DEV) {
    component_function = (component_context == null ? void 0 : component_context.function) ?? null;
  }
  let input;
  let pending_effect;
  let then_effect;
  let catch_effect;
  function create_effect(fn, value) {
    set_current_effect(effect2);
    set_current_reaction(effect2);
    set_current_component_context(component_context);
    if (DEV) {
      set_dev_current_component_function(component_function);
    }
    var e = branch(() => fn(anchor, value));
    if (DEV) {
      set_dev_current_component_function(null);
    }
    set_current_component_context(null);
    set_current_reaction(null);
    set_current_effect(null);
    flush_sync();
    return e;
  }
  const effect2 = block(() => {
    if (input === (input = get_input()))
      return;
    if (is_promise(input)) {
      const promise = (
        /** @type {Promise<any>} */
        input
      );
      if (pending_fn) {
        if (pending_effect && (pending_effect.f & INERT) === 0) {
          destroy_effect(pending_effect);
        }
        pending_effect = branch(() => pending_fn(anchor));
      }
      if (then_effect)
        pause_effect(then_effect);
      if (catch_effect)
        pause_effect(catch_effect);
      promise.then(
        (value) => {
          if (promise !== input)
            return;
          if (pending_effect)
            pause_effect(pending_effect);
          if (then_fn) {
            then_effect = create_effect(then_fn, value);
          }
        },
        (error) => {
          if (promise !== input)
            return;
          if (pending_effect)
            pause_effect(pending_effect);
          if (catch_fn) {
            catch_effect = create_effect(catch_fn, error);
          }
        }
      );
    } else {
      if (pending_effect)
        pause_effect(pending_effect);
      if (catch_effect)
        pause_effect(catch_effect);
      if (then_fn) {
        if (then_effect) {
          destroy_effect(then_effect);
        }
        then_effect = branch(() => then_fn(anchor, input));
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(anchor, get_condition, consequent_fn, alternate_fn = null, elseif = false) {
  var consequent_effect = null;
  var alternate_effect = null;
  var condition = null;
  var flags = elseif ? EFFECT_TRANSPARENT : 0;
  block(() => {
    if (condition === (condition = !!get_condition()))
      return;
    let mismatch = false;
    if (hydrating) {
      const is_else = anchor.data === HYDRATION_END_ELSE;
      if (condition === is_else) {
        remove(hydrate_nodes);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (condition) {
      if (consequent_effect) {
        resume_effect(consequent_effect);
      } else {
        consequent_effect = branch(() => consequent_fn(anchor));
      }
      if (alternate_effect) {
        pause_effect(alternate_effect, () => {
          alternate_effect = null;
        });
      }
    } else {
      if (alternate_effect) {
        resume_effect(alternate_effect);
      } else if (alternate_fn) {
        alternate_effect = branch(() => alternate_fn(anchor));
      }
      if (consequent_effect) {
        pause_effect(consequent_effect, () => {
          consequent_effect = null;
        });
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
  }, flags);
}

// node_modules/svelte/src/internal/client/dom/blocks/key.js
function key_block(anchor, get_key, render_fn) {
  let key = UNINITIALIZED;
  let effect2;
  block(() => {
    if (safe_not_equal(key, key = get_key())) {
      if (effect2) {
        pause_effect(effect2);
      }
      effect2 = branch(() => render_fn(anchor));
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(anchor, is_html, props, component2) {
  let element2;
  let component_anchor;
  if (hydrating) {
    element2 = /** @type {HTMLElement | SVGElement} */
    hydrate_nodes[0];
    component_anchor = /** @type {Comment} */
    hydrate_anchor(
      /** @type {Comment} */
      element2.firstChild
    );
  } else {
    if (is_html) {
      element2 = document.createElement("div");
      element2.style.display = "contents";
    } else {
      element2 = document.createElementNS(namespace_svg, "g");
    }
    anchor.before(element2);
    component_anchor = element2.appendChild(empty());
  }
  component2(component_anchor);
  render_effect(() => {
    let current_props = {};
    render_effect(() => {
      const next_props = props();
      for (const key in current_props) {
        if (!(key in next_props)) {
          element2.style.removeProperty(key);
        }
      }
      for (const key in next_props) {
        element2.style.setProperty(key, next_props[key]);
      }
      current_props = next_props;
    });
    return () => {
      remove(element2);
    };
  });
}

// node_modules/svelte/src/internal/client/dom/template.js
function push_template_node(dom, effect2 = (
  /** @type {import('#client').Effect} */
  current_effect
)) {
  var current_dom = effect2.dom;
  if (current_dom === null) {
    effect2.dom = dom;
  } else {
    if (!is_array(current_dom)) {
      current_dom = effect2.dom = [current_dom];
    }
    if (is_array(dom)) {
      current_dom.push(...dom);
    } else {
      current_dom.push(dom);
    }
  }
  return dom;
}
function template(content, flags) {
  var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      return push_template_node(is_fragment ? hydrate_nodes : hydrate_nodes[0]);
    }
    if (!node) {
      node = create_fragment_from_html(content);
      if (!is_fragment)
        node = /** @type {Node} */
        node.firstChild;
    }
    var clone = use_import_node ? document.importNode(node, true) : clone_node(node, true);
    push_template_node(
      is_fragment ? (
        /** @type {import('#client').TemplateNode[]} */
        [...clone.childNodes]
      ) : (
        /** @type {import('#client').TemplateNode} */
        clone
      )
    );
    return clone;
  };
}
function template_with_script(content, flags) {
  var first = true;
  var fn = template(content, flags);
  return () => {
    if (hydrating)
      return fn();
    var node = (
      /** @type {Element | DocumentFragment} */
      fn()
    );
    if (first) {
      first = false;
      run_scripts(node);
    }
    return node;
  };
}
function svg_template(content, flags) {
  var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
  var fn = template(`<svg>${content}</svg>`, 0);
  var node;
  return () => {
    if (hydrating) {
      return push_template_node(is_fragment ? hydrate_nodes : hydrate_nodes[0]);
    }
    if (!node) {
      var svg = (
        /** @type {Element} */
        fn()
      );
      if ((flags & TEMPLATE_FRAGMENT) === 0) {
        node = /** @type {Element} */
        svg.firstChild;
      } else {
        node = document.createDocumentFragment();
        while (svg.firstChild) {
          node.appendChild(svg.firstChild);
        }
      }
    }
    var clone = clone_node(node, true);
    push_template_node(
      is_fragment ? (
        /** @type {import('#client').TemplateNode[]} */
        [...clone.childNodes]
      ) : (
        /** @type {import('#client').TemplateNode} */
        clone
      )
    );
    return clone;
  };
}
function svg_template_with_script(content, flags) {
  var first = true;
  var fn = svg_template(content, flags);
  return () => {
    if (hydrating)
      return fn();
    var node = (
      /** @type {Element | DocumentFragment} */
      fn()
    );
    if (first) {
      first = false;
      run_scripts(node);
    }
    return node;
  };
}
function mathml_template(content, flags) {
  var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
  var fn = template(`<math>${content}</math>`, 0);
  var node;
  return () => {
    if (hydrating) {
      return push_template_node(is_fragment ? hydrate_nodes : hydrate_nodes[0]);
    }
    if (!node) {
      var math = (
        /** @type {Element} */
        fn()
      );
      if ((flags & TEMPLATE_FRAGMENT) === 0) {
        node = /** @type {Element} */
        math.firstChild;
      } else {
        node = document.createDocumentFragment();
        while (math.firstChild) {
          node.appendChild(math.firstChild);
        }
      }
    }
    var clone = clone_node(node, true);
    push_template_node(
      is_fragment ? (
        /** @type {import('#client').TemplateNode[]} */
        [...clone.childNodes]
      ) : (
        /** @type {import('#client').TemplateNode} */
        clone
      )
    );
    return clone;
  };
}
function run_scripts(node) {
  if (hydrating)
    return;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  for (const script of scripts) {
    var clone = document.createElement("script");
    for (var attribute of script.attributes) {
      clone.setAttribute(attribute.name, attribute.value);
    }
    clone.textContent = script.textContent;
    if (script === node) {
      effect(() => script.replaceWith(clone));
    } else {
      script.replaceWith(clone);
    }
  }
}
function text(anchor) {
  if (!hydrating)
    return push_template_node(empty());
  var node = hydrate_nodes[0];
  if (!node) {
    anchor.before(node = empty());
  }
  return push_template_node(node);
}
function comment() {
  if (hydrating) {
    return push_template_node(hydrate_nodes);
  }
  var frag = document.createDocumentFragment();
  var anchor = empty();
  frag.append(anchor);
  push_template_node([anchor]);
  return frag;
}
function append(anchor, dom) {
  if (!hydrating) {
    anchor.before(
      /** @type {Node} */
      dom
    );
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var current_each_item = null;
function set_current_each_item(item) {
  current_each_item = item;
}
function index(_, i) {
  return i;
}
function pause_effects(items, controlled_anchor, callback) {
  var transitions = [];
  var length = items.length;
  for (var i = 0; i < length; i++) {
    pause_children(items[i].e, transitions, true);
  }
  if (length > 0 && transitions.length === 0 && controlled_anchor !== null) {
    var parent_node = (
      /** @type {Element} */
      controlled_anchor.parentNode
    );
    clear_text_content(parent_node);
    parent_node.append(controlled_anchor);
  }
  run_out_transitions(transitions, () => {
    for (var i2 = 0; i2 < length; i2++) {
      destroy_effect(items[i2].e);
    }
    if (callback !== void 0)
      callback();
  });
}
function each(anchor, flags, get_collection, get_key, render_fn, fallback_fn = null) {
  var state = { flags, items: /* @__PURE__ */ new Map(), next: null };
  var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      anchor
    );
    anchor = hydrating ? (
      /** @type {Comment | Text} */
      hydrate_anchor(
        /** @type {Comment | Text} */
        parent_node.firstChild
      )
    ) : parent_node.appendChild(empty());
  }
  var fallback = null;
  block(() => {
    var collection = get_collection();
    var array = is_array(collection) ? collection : collection == null ? [] : Array.from(collection);
    var length = array.length;
    var flags2 = state.flags;
    if ((flags2 & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {
      flags2 ^= EACH_IS_STRICT_EQUALS;
      if ((flags2 & EACH_KEYED) !== 0 && (flags2 & EACH_ITEM_REACTIVE) === 0) {
        flags2 ^= EACH_ITEM_REACTIVE;
      }
    }
    let mismatch = false;
    if (hydrating) {
      var is_else = (
        /** @type {Comment} */
        anchor.data === HYDRATION_END_ELSE
      );
      if (is_else !== (length === 0)) {
        remove(hydrate_nodes);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (hydrating) {
      var child_anchor = hydrate_nodes[0];
      var prev = state;
      var item;
      for (var i = 0; i < length; i++) {
        if (child_anchor.nodeType !== 8 || /** @type {Comment} */
        child_anchor.data !== HYDRATION_START) {
          mismatch = true;
          set_hydrating(false);
          break;
        }
        var child_open = (
          /** @type {Comment} */
          child_anchor
        );
        child_anchor = hydrate_anchor(child_anchor);
        var value = array[i];
        var key = get_key(value, i);
        item = create_item(child_open, child_anchor, prev, null, value, key, i, render_fn, flags2);
        state.items.set(key, item);
        child_anchor = /** @type {Comment} */
        child_anchor.nextSibling;
        prev = item;
      }
      if (length > 0) {
        while (child_anchor !== anchor) {
          var next = (
            /** @type {import('#client').TemplateNode} */
            child_anchor.nextSibling
          );
          child_anchor.remove();
          child_anchor = next;
        }
      }
    }
    if (!hydrating) {
      reconcile(array, state, anchor, render_fn, flags2, get_key);
    }
    if (fallback_fn !== null) {
      if (length === 0) {
        if (fallback) {
          resume_effect(fallback);
        } else {
          fallback = branch(() => fallback_fn(anchor));
        }
      } else if (fallback !== null) {
        pause_effect(fallback, () => {
          fallback = null;
        });
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
  });
}
function reconcile(array, state, anchor, render_fn, flags, get_key) {
  var _a, _b, _c, _d;
  var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
  var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
  var length = array.length;
  var items = state.items;
  var first = state.next;
  var current = first;
  var seen = /* @__PURE__ */ new Set();
  var prev = state;
  var to_animate = /* @__PURE__ */ new Set();
  var matched = [];
  var stashed = [];
  var value;
  var key;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key = get_key(value, i);
      item = items.get(key);
      if (item !== void 0) {
        (_a = item.a) == null ? void 0 : _a.measure();
        to_animate.add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key = get_key(value, i);
    item = items.get(key);
    if (item === void 0) {
      var child_open = push_template_node(empty());
      var child_anchor = current ? current.o : anchor;
      child_anchor.before(child_open);
      prev = create_item(
        child_open,
        child_anchor,
        prev,
        prev.next,
        value,
        key,
        i,
        render_fn,
        flags
      );
      items.set(key, prev);
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if (should_update) {
      update_item(item, value, i, flags);
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        (_b = item.a) == null ? void 0 : _b.unfix();
        to_animate.delete(item);
      }
    }
    if (item !== current) {
      if (seen.has(item)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(a.prev, b.next);
          link(prev, a);
          link(b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(item);
          move(item, current, anchor);
          link(item.prev, item.next);
          link(item, prev.next);
          link(prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key) {
        seen.add(current);
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  const to_destroy = Array.from(seen);
  while (current) {
    to_destroy.push(current);
    current = current.next;
  }
  var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
  if (is_animated) {
    for (i = 0; i < to_destroy.length; i += 1) {
      (_c = to_destroy[i].a) == null ? void 0 : _c.measure();
    }
    for (i = 0; i < to_destroy.length; i += 1) {
      (_d = to_destroy[i].a) == null ? void 0 : _d.fix();
    }
  }
  pause_effects(to_destroy, controlled_anchor, () => {
    for (var i2 = 0; i2 < to_destroy.length; i2 += 1) {
      var item2 = to_destroy[i2];
      items.delete(item2.k);
      link(item2.prev, item2.next);
    }
  });
  if (is_animated) {
    effect(() => {
      untrack(() => {
        var _a2;
        for (item of to_animate) {
          (_a2 = item.a) == null ? void 0 : _a2.apply();
        }
      });
    });
  }
}
function update_item(item, value, index2, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    set(item.v, value);
  }
  if ((type & EACH_INDEX_REACTIVE) !== 0) {
    set(
      /** @type {import('#client').Value<number>} */
      item.i,
      index2
    );
  } else {
    item.i = index2;
  }
}
function create_item(open, anchor, prev, next, value, key, index2, render_fn, flags) {
  var previous_each_item = current_each_item;
  try {
    var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    var mutable = (flags & EACH_IS_STRICT_EQUALS) === 0;
    var v = reactive ? mutable ? mutable_source(value) : source(value) : value;
    var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
    var item = {
      i,
      v,
      k: key,
      a: null,
      // @ts-expect-error
      e: null,
      o: open,
      prev,
      next
    };
    prev.next = item;
    if (next !== null)
      next.prev = item;
    current_each_item = item;
    item.e = branch(() => render_fn(anchor, v, i));
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function move(item, next, anchor) {
  var end = item.next ? item.next.o : anchor;
  var dest = next ? next.o : anchor;
  var node = (
    /** @type {import('#client').TemplateNode} */
    item.o
  );
  while (node !== end) {
    var next_node = (
      /** @type {import('#client').TemplateNode} */
      node.nextSibling
    );
    dest.before(node);
    node = next_node;
  }
}
function link(prev, next) {
  prev.next = next;
  if (next !== null)
    next.prev = prev;
}

// node_modules/svelte/src/internal/client/dom/blocks/html.js
function remove_from_parent_effect(effect2, to_remove) {
  const dom = effect2.dom;
  if (is_array(dom)) {
    for (let i = dom.length - 1; i >= 0; i--) {
      if (to_remove.includes(dom[i])) {
        dom.splice(i, 1);
        break;
      }
    }
  } else if (dom !== null && to_remove.includes(dom)) {
    effect2.dom = null;
  }
}
function html(anchor, get_value, svg, mathml) {
  var _a;
  const parent_effect = anchor.parentNode !== ((_a = current_effect) == null ? void 0 : _a.dom) ? current_effect : null;
  let value = derived(get_value);
  render_effect(() => {
    var dom = html_to_dom(anchor, parent_effect, get(value), svg, mathml);
    if (dom) {
      return () => {
        if (parent_effect !== null) {
          remove_from_parent_effect(parent_effect, is_array(dom) ? dom : [dom]);
        }
        remove(dom);
      };
    }
  });
}
function html_to_dom(target, effect2, value, svg, mathml) {
  if (hydrating)
    return hydrate_nodes;
  var html2 = value + "";
  if (svg)
    html2 = `<svg>${html2}</svg>`;
  else if (mathml)
    html2 = `<math>${html2}</math>`;
  var node = create_fragment_from_html(html2);
  if (svg || mathml) {
    node = /** @type {Element} */
    node.firstChild;
  }
  if (node.childNodes.length === 1) {
    var child2 = (
      /** @type {Text | Element | Comment} */
      node.firstChild
    );
    target.before(child2);
    if (effect2 !== null) {
      push_template_node(child2, effect2);
    }
    return child2;
  }
  var nodes = (
    /** @type {Array<Text | Element | Comment>} */
    [...node.childNodes]
  );
  if (svg || mathml) {
    while (node.firstChild) {
      target.before(node.firstChild);
    }
  } else {
    target.before(node);
  }
  if (effect2 !== null) {
    push_template_node(nodes, effect2);
  }
  return nodes;
}

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(get_snippet, node, ...args) {
  var snippet2;
  var snippet_effect;
  block(() => {
    if (snippet2 === (snippet2 = get_snippet()))
      return;
    if (snippet_effect) {
      destroy_effect(snippet_effect);
      snippet_effect = null;
    }
    if (snippet2) {
      snippet_effect = branch(() => (
        /** @type {SnippetFn} */
        snippet2(node, ...args)
      ));
    }
  }, EFFECT_TRANSPARENT);
}
function wrap_snippet(fn) {
  let component2 = (
    /** @type {import('#client').ComponentContext} */
    current_component_context
  );
  return add_snippet_symbol(
    (node, ...args) => {
      var previous_component_function = dev_current_component_function;
      set_dev_current_component_function(component2.function);
      try {
        return fn(node, ...args);
      } finally {
        set_dev_current_component_function(previous_component_function);
      }
    }
  );
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(anchor, get_component2, render_fn) {
  let component2;
  let effect2;
  block(() => {
    if (component2 === (component2 = get_component2()))
      return;
    if (effect2) {
      pause_effect(effect2);
      effect2 = null;
    }
    if (component2) {
      effect2 = branch(() => render_fn(component2));
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function swap_block_dom(effect2, from, to) {
  const dom = effect2.dom;
  if (is_array(dom)) {
    for (let i = 0; i < dom.length; i++) {
      if (dom[i] === from) {
        dom[i] = to;
        break;
      }
    }
  } else if (dom === from) {
    effect2.dom = to;
  }
}
function element(anchor, get_tag, is_svg, render_fn, get_namespace, location) {
  var _a;
  const parent_effect = (
    /** @type {import('#client').Effect} */
    current_effect
  );
  const filename = DEV && location && ((_a = current_component_context) == null ? void 0 : _a.function.filename);
  render_effect(() => {
    let tag;
    let current_tag;
    let element2 = null;
    let effect2;
    let each_item_block = current_each_item;
    block(() => {
      const next_tag = get_tag() || null;
      const ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? namespace_svg : null;
      if (next_tag === tag)
        return;
      var previous_each_item = current_each_item;
      set_current_each_item(each_item_block);
      if (effect2) {
        if (next_tag === null) {
          pause_effect(effect2, () => {
            effect2 = null;
            current_tag = null;
            element2 == null ? void 0 : element2.remove();
          });
        } else if (next_tag === current_tag) {
          resume_effect(effect2);
        } else {
          destroy_effect(effect2);
          set_should_intro(false);
        }
      }
      if (next_tag && next_tag !== current_tag) {
        effect2 = branch(() => {
          const prev_element = element2;
          element2 = hydrating ? (
            /** @type {Element} */
            hydrate_nodes[0]
          ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
          if (DEV && location) {
            element2.__svelte_meta = {
              loc: {
                file: filename,
                line: location[0],
                column: location[1]
              }
            };
          }
          if (render_fn) {
            var child_anchor = hydrating ? element2.firstChild && hydrate_anchor(
              /** @type {Comment} */
              element2.firstChild
            ) : element2.appendChild(empty());
            if (hydrating && !element2.firstChild) {
              set_hydrate_nodes([empty()]);
            }
            render_fn(element2, child_anchor);
          }
          anchor.before(element2);
          if (prev_element) {
            swap_block_dom(parent_effect, prev_element, element2);
            prev_element.remove();
          } else if (!hydrating) {
            push_template_node(element2, parent_effect);
          }
        });
      }
      tag = next_tag;
      if (tag)
        current_tag = tag;
      set_should_intro(true);
      set_current_each_item(previous_each_item);
    });
    return () => {
      element2 == null ? void 0 : element2.remove();
    };
  });
}

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value == null ? void 0 : get_value()) || {});
    if (get_value && (payload == null ? void 0 : payload.update)) {
      var inited = false;
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited) {
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload == null ? void 0 : payload.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    effect(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && dom.firstChild !== null) {
    clear_text_content(dom);
  }
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
function remove_input_attr_defaults(dom) {
  if (hydrating) {
    const value = dom.getAttribute("value");
    set_attribute(dom, "value", null);
    set_attribute(dom, "checked", null);
    if (value)
      dom.value = value;
  }
}
function set_attribute(element2, attribute, value) {
  value = value == null ? null : value + "";
  var attributes = element2.__attributes ?? (element2.__attributes = {});
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "href" || attribute === "srcset") {
      check_src_in_dev_hydration(element2, attribute, value);
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value))
    return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value === null) {
    element2.removeAttribute(attribute);
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_xlink_attribute(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data(node, prop2, value) {
  if (prop2 in node) {
    var curr_val = node[prop2];
    var next_val = typeof curr_val === "boolean" && value === "" ? true : value;
    if (typeof curr_val !== "object" || curr_val !== next_val) {
      node[prop2] = next_val;
    }
  } else {
    set_attribute(node, prop2, value);
  }
}
function set_attributes(element2, prev, next, lowercase_attributes, css_hash) {
  var has_hash = css_hash.length !== 0;
  for (var key in prev) {
    if (!(key in next)) {
      next[key] = null;
    }
  }
  if (has_hash && !next.class) {
    next.class = "";
  }
  var setters = map_get(setters_cache, element2.nodeName);
  if (!setters)
    map_set(setters_cache, element2.nodeName, setters = get_setters(element2));
  var attributes = (
    /** @type {Record<string, unknown>} **/
    element2.__attributes ?? (element2.__attributes = {})
  );
  var events = [];
  for (key in next) {
    let value = next[key];
    if (value === (prev == null ? void 0 : prev[key]))
      continue;
    var prefix = key[0] + key[1];
    if (prefix === "$$")
      continue;
    if (prefix === "on") {
      const opts = {};
      let event_name = key.slice(2);
      var delegated = DelegatedEvents.includes(event_name);
      if (event_name.endsWith("capture") && event_name !== "ongotpointercapture" && event_name !== "onlostpointercapture") {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && (prev == null ? void 0 : prev[key])) {
        element2.removeEventListener(
          event_name,
          /** @type {any} */
          prev[key],
          opts
        );
      }
      if (value != null) {
        if (!delegated) {
          if (!prev) {
            events.push([key, value, () => element2.addEventListener(event_name, value, opts)]);
          } else {
            element2.addEventListener(event_name, value, opts);
          }
        } else {
          element2[`__${event_name}`] = value;
          delegate([event_name]);
        }
      }
    } else if (value == null) {
      attributes[key] = null;
      element2.removeAttribute(key);
    } else if (key === "style") {
      element2.style.cssText = value + "";
    } else if (key === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (key === "__value" || key === "value") {
      element2.value = element2[key] = element2.__value = value;
    } else {
      var name = key;
      if (lowercase_attributes) {
        name = name.toLowerCase();
        name = AttributeAliases[name] || name;
      }
      if (setters.includes(name)) {
        if (hydrating && (name === "src" || name === "href" || name === "srcset")) {
          check_src_in_dev_hydration(element2, name, value);
        } else {
          element2[name] = value;
        }
      } else if (typeof value !== "function") {
        if (has_hash && name === "class") {
          if (value)
            value += " ";
          value += css_hash;
        }
        set_attribute(element2, name, value);
      }
    }
  }
  if (!prev) {
    const destroy_root = effect_root(() => {
      effect(() => {
        if (!element2.isConnected)
          return;
        for (const [key2, value, evt] of events) {
          if (next[key2] === value) {
            evt();
          }
        }
        destroy_root();
      });
    });
  }
  return next;
}
function set_dynamic_element_attributes(node, prev, next, css_hash) {
  if (node.tagName.includes("-")) {
    for (var key in prev) {
      if (!(key in next)) {
        next[key] = null;
      }
    }
    for (key in next) {
      set_custom_element_data(node, key, next[key]);
    }
    return next;
  }
  return set_attributes(
    /** @type {Element & ElementCSSInlineStyle} */
    node,
    prev,
    next,
    node.namespaceURI !== namespace_svg,
    css_hash
  );
}
var always_set_through_set_attribute = ["width", "height"];
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var setters = [];
  var descriptors;
  var proto = get_prototype_of(element2);
  while (proto.constructor.name !== "Element") {
    descriptors = get_descriptors(proto);
    for (var key in descriptors) {
      if (descriptors[key].set && !always_set_through_set_attribute.includes(key)) {
        setters.push(key);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  if (!DEV)
    return;
  if (attribute === "srcset" && srcset_url_equal(element2, value))
    return;
  if (src_url_equal(element2.getAttribute(attribute) ?? "", value ?? ""))
    return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset ?? "");
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}
function handle_lazy_img(element2) {
  if (!hydrating && element2.loading === "lazy") {
    var src = element2.src;
    element2[LOADING_ATTR_SYMBOL] = null;
    element2.loading = "eager";
    element2.removeAttribute("src");
    requestAnimationFrame(() => {
      if (element2[LOADING_ATTR_SYMBOL] !== "eager") {
        element2.loading = "lazy";
      }
      element2.src = src;
    });
  }
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_svg_class(dom, value) {
  var prev_class_name = dom.__className;
  var next_class_name = to_class(value);
  if (hydrating && dom.getAttribute("class") === next_class_name) {
    dom.__className = next_class_name;
  } else if (prev_class_name !== next_class_name || hydrating && dom.getAttribute("class") !== next_class_name) {
    if (next_class_name === "") {
      dom.removeAttribute("class");
    } else {
      dom.setAttribute("class", next_class_name);
    }
    dom.__className = next_class_name;
  }
}
function set_mathml_class(dom, value) {
  var prev_class_name = dom.__className;
  var next_class_name = to_class(value);
  if (hydrating && dom.getAttribute("class") === next_class_name) {
    dom.__className = next_class_name;
  } else if (prev_class_name !== next_class_name || hydrating && dom.getAttribute("class") !== next_class_name) {
    if (next_class_name === "") {
      dom.removeAttribute("class");
    } else {
      dom.setAttribute("class", next_class_name);
    }
    dom.__className = next_class_name;
  }
}
function set_class(dom, value) {
  var prev_class_name = dom.__className;
  var next_class_name = to_class(value);
  if (hydrating && dom.className === next_class_name) {
    dom.__className = next_class_name;
  } else if (prev_class_name !== next_class_name || hydrating && dom.className !== next_class_name) {
    if (value == null) {
      dom.removeAttribute("class");
    } else {
      set_class_name(dom, next_class_name);
    }
    dom.__className = next_class_name;
  }
}
function to_class(value) {
  return value == null ? "" : value;
}
function toggle_class(dom, class_name, value) {
  if (value) {
    dom.classList.add(class_name);
  } else {
    dom.classList.remove(class_name);
  }
}

// node_modules/svelte/src/internal/client/dom/elements/style.js
function set_style(dom, key, value, important) {
  const style = dom.style;
  const prev_value = style.getPropertyValue(key);
  if (value == null) {
    if (prev_value !== "") {
      style.removeProperty(key);
    }
  } else if (prev_value !== value) {
    style.setProperty(key, value, important ? "important" : "");
  }
}

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element2, type) {
  element2.dispatchEvent(new CustomEvent(type));
}
function css_style_from_camel_case(style) {
  const parts = style.split("-");
  if (parts.length === 1)
    return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0)
      break;
    const formatted_property = css_style_from_camel_case(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var linear = (t) => t;
function animation(element2, get_fn, get_params) {
  var item = (
    /** @type {import('#client').EachItem} */
    current_each_item
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  item.a ?? (item.a = {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2 == null ? void 0 : animation2.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params == null ? void 0 : get_params());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2 == null ? void 0 : animation2.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      var computed_style = getComputedStyle(element2);
      if (computed_style.position !== "absolute" && computed_style.position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height
        };
        style.position = "absolute";
        style.width = computed_style.width;
        style.height = computed_style.height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
      }
    }
  });
  item.a.element = element2;
}
function transition(flags, element2, get_fn, get_params) {
  var is_intro = (flags & TRANSITION_IN) !== 0;
  var is_outro = (flags & TRANSITION_OUT) !== 0;
  var is_global = (flags & TRANSITION_GLOBAL) !== 0;
  var direction = is_intro && is_outro ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var intro;
  var outro;
  var reset;
  function get_options() {
    return current_options ?? (current_options = get_fn()(element2, get_params == null ? void 0 : get_params(), { direction }));
  }
  var transition2 = {
    is_global,
    in() {
      element2.inert = inert;
      if (is_intro) {
        dispatch_event(element2, "introstart");
        intro = animate(element2, get_options(), outro, 1, () => {
          dispatch_event(element2, "introend");
          intro = current_options = void 0;
        });
      } else {
        outro == null ? void 0 : outro.abort();
        reset == null ? void 0 : reset();
      }
    },
    out(fn) {
      if (is_outro) {
        element2.inert = true;
        dispatch_event(element2, "outrostart");
        outro = animate(element2, get_options(), intro, 0, () => {
          dispatch_event(element2, "outroend");
          outro = current_options = void 0;
          fn == null ? void 0 : fn();
        });
        reset = outro.reset;
      } else {
        fn == null ? void 0 : fn();
      }
    },
    stop: () => {
      intro == null ? void 0 : intro.abort();
      outro == null ? void 0 : outro.abort();
    }
  };
  var e = (
    /** @type {import('#client').Effect} */
    current_effect
  );
  (e.transitions ?? (e.transitions = [])).push(transition2);
  if (is_intro && should_intro) {
    let run2 = is_global;
    if (!run2) {
      var block2 = (
        /** @type {import('#client').Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0)
            break;
        }
      }
      run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run2) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element2, options, counterpart, t2, callback) {
  if (is_function(options)) {
    var a;
    effect(() => {
      var o = untrack(() => options({ direction: t2 === 1 ? "in" : "out" }));
      a = animate(element2, o, counterpart, t2, callback);
    });
    return {
      abort: () => a.abort(),
      deactivate: () => a.deactivate(),
      reset: () => a.reset(),
      t: (now) => a.t(now)
    };
  }
  counterpart == null ? void 0 : counterpart.deactivate();
  if (!(options == null ? void 0 : options.duration)) {
    callback == null ? void 0 : callback();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t2
    };
  }
  var { delay = 0, duration, css, tick: tick2, easing = linear } = options;
  var start = raf.now() + delay;
  var t1 = (counterpart == null ? void 0 : counterpart.t(start)) ?? 1 - t2;
  var delta = t2 - t1;
  duration *= Math.abs(delta);
  var end = start + duration;
  var animation2;
  var task;
  if (css) {
    var keyframes = [];
    var n = Math.ceil(duration / (1e3 / 60));
    for (var i = 0; i <= n; i += 1) {
      var t = t1 + delta * easing(i / n);
      var styles = css(t, 1 - t);
      keyframes.push(css_to_keyframe(styles));
    }
    animation2 = element2.animate(keyframes, {
      delay,
      duration,
      easing: "linear",
      fill: "forwards"
    });
    animation2.finished.then(() => {
      callback == null ? void 0 : callback();
      if (t2 === 1) {
        animation2.cancel();
      }
    }).catch((e) => {
      if (animation2.startTime !== null && animation2.currentTime !== null) {
        throw e;
      }
    });
  } else {
    if (t1 === 0) {
      tick2 == null ? void 0 : tick2(0, 1);
    }
    task = loop((now) => {
      if (now >= end) {
        tick2 == null ? void 0 : tick2(t2, 1 - t2);
        callback == null ? void 0 : callback();
        return false;
      }
      if (now >= start) {
        var p = t1 + delta * easing((now - start) / duration);
        tick2 == null ? void 0 : tick2(p, 1 - p);
      }
      return true;
    });
  }
  return {
    abort: () => {
      animation2 == null ? void 0 : animation2.cancel();
      task == null ? void 0 : task.abort();
    },
    deactivate: () => {
      callback = void 0;
    },
    reset: () => {
      if (t2 === 0) {
        tick2 == null ? void 0 : tick2(1, 0);
      }
    },
    t: (now) => {
      var t3 = t1 + delta * easing((now - start) / duration);
      return Math.min(1, Math.max(0, t3));
    }
  };
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  render_effect(() => {
    return () => {
      for (var name2 of events) {
        target.removeEventListener(name2, handler);
      }
    };
  });
}
var listening_to_form_reset = false;
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, handler);
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset();
    };
  } else {
    element2.__on_r = on_reset;
  }
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          var _a;
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              (_a = e.__on_r) == null ? void 0 : _a.call(e);
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
      { capture: true }
    );
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get_value, update2) {
  listen_to_event_and_reset_event(input, "input", () => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    update2(is_numberlike_input(input) ? to_number(input.value) : input.value);
  });
  render_effect(() => {
    if (DEV && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get_value();
    input.__value = value;
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    input.value = stringify(value);
  });
}
function bind_group(inputs, group_index, input, get_value, update2) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  if (group_index !== null) {
    for (var index2 of group_index) {
      var group = binding_group;
      binding_group = group[index2];
      if (binding_group === void 0) {
        binding_group = group[index2] = [];
      }
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value = input.__value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      }
      update2(value);
    },
    // TODO better default value handling
    () => update2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value = get_value();
    if (is_checkbox) {
      value = value || [];
      input.checked = get_proxied_value(value).includes(get_proxied_value(input.__value));
    } else {
      input.checked = is(input.__value, value);
    }
  });
  render_effect(() => {
    return () => {
      var index3 = binding_group.indexOf(input);
      if (index3 !== -1) {
        binding_group.splice(index3, 1);
      }
    };
  });
  effect(() => {
    binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
  });
}
function bind_checked(input, get_value, update2) {
  listen_to_event_and_reset_event(input, "change", () => {
    var value = input.checked;
    update2(value);
  });
  if (get_value() == void 0) {
    update2(false);
  }
  render_effect(() => {
    var value = get_value();
    input.checked = Boolean(value);
  });
}
function get_binding_group_value(group, __value, checked) {
  var value = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_files(input, get_value, update2) {
  listen_to_event_and_reset_event(input, "change", () => {
    update2(input.files);
  });
  render_effect(() => {
    input.files = get_value();
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get_value, update2) {
  var raf_id;
  var updating = false;
  var callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    updating = true;
    update2(media.currentTime);
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.currentTime = /** @type {number} */
      value;
    }
    updating = false;
  });
  render_effect(() => () => cancelAnimationFrame(raf_id));
}
function bind_buffered(media, update2) {
  listen(media, ["loadedmetadata", "progress"], () => update2(time_ranges_to_array(media.buffered)));
}
function bind_seekable(media, update2) {
  listen(media, ["loadedmetadata"], () => update2(time_ranges_to_array(media.seekable)));
}
function bind_played(media, update2) {
  listen(media, ["timeupdate"], () => update2(time_ranges_to_array(media.played)));
}
function bind_seeking(media, update2) {
  listen(media, ["seeking", "seeked"], () => update2(media.seeking));
}
function bind_ended(media, update2) {
  listen(media, ["timeupdate", "ended"], () => update2(media.ended));
}
function bind_ready_state(media, update2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => update2(media.readyState)
  );
}
function bind_playback_rate(media, get_value, update2) {
  var updating = false;
  effect(() => {
    var value = get_value();
    if (!isNaN(
      /** @type {any} */
      value
    ) && value !== media.playbackRate) {
      updating = true;
      media.playbackRate = /** @type {number} */
      value;
    }
    listen(media, ["ratechange"], () => {
      if (!updating)
        update2(media.playbackRate);
      updating = false;
    });
  });
}
function bind_paused(media, get_value, update2) {
  var mounted = hydrating;
  var paused = get_value();
  var callback = () => {
    if (paused !== media.paused) {
      paused = media.paused;
      update2(paused = media.paused);
    }
  };
  if (paused == null) {
    callback();
  }
  if (mounted) {
    listen(media, ["play", "pause", "canplay"], callback, false);
  }
  render_effect(() => {
    paused = !!get_value();
    if (paused !== media.paused) {
      var toggle = () => {
        mounted = true;
        if (paused) {
          media.pause();
        } else {
          media.play().catch(() => {
            update2(paused = true);
          });
        }
      };
      if (mounted) {
        toggle();
      } else {
        media.addEventListener(
          "canplay",
          () => {
            listen(media, ["play", "pause", "canplay"], callback, false);
            toggle();
          },
          { once: true }
        );
      }
    }
  });
}
function bind_volume(media, get_value, update2) {
  var updating = false;
  var callback = () => {
    updating = true;
    update2(media.volume);
  };
  if (get_value() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = get_value();
    if (!updating && !isNaN(
      /** @type {any} */
      value
    )) {
      media.volume = /** @type {number} */
      value;
    }
    updating = false;
  });
}
function bind_muted(media, get_value, update2) {
  var updating = false;
  var callback = () => {
    updating = true;
    update2(media.muted);
  };
  if (get_value() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = get_value();
    if (!updating)
      media.muted = !!value;
    updating = false;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
function bind_prop(props, prop2, value) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    render_effect(() => () => {
      props[prop2] = null;
    });
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting) {
  if (select.multiple) {
    return select_options(select, value);
  }
  for (var option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select, get_value) {
  effect(() => {
    if (get_value) {
      select_option(select, untrack(get_value));
    }
    var observer = new MutationObserver(() => {
      var value = select.__value;
      select_option(select, value);
    });
    observer.observe(select, {
      // Listen to option element changes
      childList: true,
      subtree: true,
      // because of <optgroup>
      // Listen to option element value attribute changes
      // (doesn't get notified of select value changes,
      // because that property is not reflected as an attribute)
      attributes: true,
      attributeFilter: ["value"]
    });
    return () => {
      observer.disconnect();
    };
  });
}
function bind_select_value(select, get_value, update2) {
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", () => {
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(":checked"), get_option_value);
    } else {
      var selected_option = select.querySelector(":checked");
      value = selected_option && get_option_value(selected_option);
    }
    update2(value);
  });
  effect(() => {
    var value = get_value();
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        update2(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select(select);
}
function select_options(select, value) {
  for (var option of select.options) {
    option.selected = ~value.indexOf(get_option_value(option));
  }
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var _listeners, _observer, _options, _getObserver, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _getObserver);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer, void 0);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _getObserver, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_getObserver = new WeakSet();
getObserver_fn = function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (var entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(element2, type, update2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element2,
    /** @param {any} entry */
    (entry) => update2(entry[type])
  );
  render_effect(() => unsub);
}
function bind_element_size(element2, type, update2) {
  var unsub = resize_observer_border_box.observe(element2, () => update2(element2[type]));
  effect(() => {
    untrack(() => update2(element2[type]));
    return unsub;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  var _a;
  var proxy_target = bound_value && ((_a = bound_value[STATE_SYMBOL]) == null ? void 0 : _a.t);
  return bound_value === element_or_component || proxy_target === element_or_component;
}
function bind_this(element_or_component, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = (get_parts == null ? void 0 : get_parts()) || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
function bind_content_editable(property, element2, get_value, update2) {
  element2.addEventListener("input", () => {
    update2(element2[property]);
  });
  render_effect(() => {
    var value = get_value();
    if (element2[property] !== value) {
      if (value === null) {
        var non_null_value = element2[property];
        update2(non_null_value);
      } else {
        element2[property] = value + "";
      }
    }
  });
}
function bind_property(property, event_name, type, element2, get_value, update2) {
  var target_handler = () => {
    update2(element2[property]);
  };
  element2.addEventListener(event_name, target_handler);
  if (type === "set") {
    render_effect(() => {
      element2[property] = get_value();
    });
  }
  if (type === "get") {
    update2(element2[property]);
  }
  render_effect(() => {
    if (element2 === document.body || element2 === window || element2 === document) {
      return () => {
        element2.removeEventListener(event_name, target_handler);
      };
    }
  });
}
function bind_focused(element2, update2) {
  listen(element2, ["focus", "blur"], () => {
    update2(element2 === document.activeElement);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
function bind_window_scroll(type, get_value, update2) {
  var is_scrolling_x = type === "x";
  var target_handler = () => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    update2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  };
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear = () => {
    scrolling = false;
  };
  var first = true;
  render_effect(() => {
    var latest_value = get_value();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  effect(() => {
    var value = window[is_scrolling_x ? "scrollX" : "scrollY"];
    if (value === 0) {
      update2(value);
    }
  });
  render_effect(() => {
    return () => {
      removeEventListener("scroll", target_handler);
    };
  });
}
function bind_window_size(type, update2) {
  listen(window, ["resize"], () => update2(window[type]));
}

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
function trusted(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn.apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn.apply(this, args);
  };
}
function once(fn) {
  var ran = false;
  return function(...args) {
    if (ran)
      return;
    ran = true;
    return fn.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn.apply(this, args);
  };
}

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init() {
  const context = (
    /** @type {import('#client').ComponentContextLegacy} */
    current_component_context
  );
  const callbacks = context.l.u;
  if (!callbacks)
    return;
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context) {
  if (context.l.s) {
    for (const signal of context.l.s)
      get(signal);
  }
  deep_read_state(context.s);
}

// node_modules/svelte/src/internal/client/reactivity/props.js
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
var rest_props_handler = {
  get(target, key) {
    if (target.exclude.includes(key))
      return;
    return target.props[key];
  },
  set(target, key) {
    if (DEV) {
      props_rest_readonly(`${target.name}.${String(key)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key) {
    if (target.exclude.includes(key))
      return;
    if (key in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key]
      };
    }
  },
  has(target, key) {
    if (target.exclude.includes(key))
      return false;
    return key in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
  }
};
function rest_props(props, exclude, name) {
  return new Proxy(
    DEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
var legacy_rest_props_handler = {
  get(target, key) {
    if (target.exclude.includes(key))
      return;
    get(target.version);
    return key in target.special ? target.special[key]() : target.props[key];
  },
  set(target, key, value) {
    if (!(key in target.special)) {
      target.special[key] = prop(
        {
          get [key]() {
            return target.props[key];
          }
        },
        /** @type {string} */
        key,
        PROPS_IS_UPDATED
      );
    }
    target.special[key](value);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key) {
    if (target.exclude.includes(key))
      return;
    if (key in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key]
      };
    }
  },
  has(target, key) {
    if (target.exclude.includes(key))
      return false;
    return key in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);
}
var spread_props_handler = {
  get(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return p[key];
    }
  },
  getOwnPropertyDescriptor(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return get_descriptor(p, key);
    }
  },
  has(target, key) {
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      if (p != null && key in p)
        return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      for (const key in p) {
        if (!keys.includes(key))
          keys.push(key);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key, flags, fallback) {
  var _a;
  var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
  var runes = (flags & PROPS_IS_RUNES) !== 0;
  var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
  var prop_value = (
    /** @type {V} */
    props[key]
  );
  var setter = (_a = get_descriptor(props, key)) == null ? void 0 : _a.set;
  var fallback_value = (
    /** @type {V} */
    fallback
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (lazy && fallback_dirty) {
      fallback_dirty = false;
      fallback_value = untrack(
        /** @type {() => V} */
        fallback
      );
    }
    return fallback_value;
  };
  if (prop_value === void 0 && fallback !== void 0) {
    if (setter && runes) {
      props_invalid_value(key);
    }
    prop_value = get_fallback();
    if (setter)
      setter(prop_value);
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key]
      );
      if (value === void 0)
        return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    var derived_getter = (immutable ? derived : derived_safe_equal)(
      () => (
        /** @type {V} */
        props[key]
      )
    );
    derived_getter.f |= LEGACY_DERIVED_PROP;
    getter = () => {
      var value = get(derived_getter);
      if (value !== void 0)
        fallback_value = /** @type {V} */
        void 0;
      return value === void 0 ? fallback_value : value;
    };
  }
  if ((flags & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    return function(value) {
      if (arguments.length === 1) {
        setter(value);
        return value;
      } else {
        return getter();
      }
    };
  }
  var from_child = false;
  var was_from_child = false;
  var inner_current_value = mutable_source(prop_value);
  var current_value = derived(() => {
    var parent_value = getter();
    var child_value = get(inner_current_value);
    if (from_child) {
      from_child = false;
      was_from_child = true;
      return child_value;
    }
    was_from_child = false;
    return inner_current_value.v = parent_value;
  });
  if (!immutable)
    current_value.equals = safe_equals;
  return function(value) {
    var current = get(current_value);
    if (is_signals_recorded || DEV && inspect_fn) {
      from_child = was_from_child;
      getter();
      get(inner_current_value);
    }
    if (arguments.length > 0) {
      if (!current_value.equals(value)) {
        from_child = true;
        set(inner_current_value, value);
        get(current_value);
      }
      return value;
    }
    return current;
  };
}

// node_modules/svelte/src/internal/client/reactivity/store.js
function store_get(store, store_name, stores) {
  let entry = stores[store_name];
  const is_new = entry === void 0;
  if (is_new) {
    entry = {
      store: null,
      last_value: null,
      value: mutable_source(UNINITIALIZED),
      unsubscribe: noop
    };
    stores[store_name] = entry;
  }
  if (is_new || entry.store !== store) {
    entry.unsubscribe();
    entry.store = store ?? null;
    entry.unsubscribe = connect_store_to_signal(store, entry.value);
  }
  const value = get(entry.value);
  return value === UNINITIALIZED ? entry.last_value : value;
}
function store_unsub(store, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store;
}
function connect_store_to_signal(store, source2) {
  if (store == null) {
    set(source2, void 0);
    return noop;
  }
  return subscribe_to_store(store, (v) => set(source2, v));
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function invalidate_store(stores, store_name) {
  const store = stores[store_name];
  if (store.store) {
    store_set(store.store, store.value.v);
  }
}
function unsubscribe_on_destroy(stores) {
  on_destroy(() => {
    let store_name;
    for (store_name in stores) {
      const ref = stores[store_name];
      ref.unsubscribe();
    }
  });
}
function mutate_store(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function on_destroy(fn) {
  effect(() => () => untrack(fn));
}

// node_modules/svelte/src/internal/client/validate.js
function validate_dynamic_component(component_fn) {
  try {
    const instance = component_fn();
    if (instance !== void 0 && typeof instance !== "object") {
      svelte_component_invalid_this_value();
    }
    return instance;
  } catch (err) {
    const { message } = (
      /** @type {Error} */
      err
    );
    if (typeof message === "string" && message.indexOf("is not a function") !== -1) {
      svelte_component_invalid_this_value();
    }
    throw err;
  }
}
function validate_each_keys(collection, key_fn) {
  const keys = /* @__PURE__ */ new Map();
  const maybe_array = untrack(() => collection());
  const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
  const length = array.length;
  for (let i = 0; i < length; i++) {
    const key = key_fn(array[i], i);
    if (keys.has(key)) {
      const a = String(keys.get(key));
      const b = String(i);
      let k = String(array[i]);
      if (k.startsWith("[object "))
        k = null;
      each_key_duplicate(a, b, k);
    }
    keys.set(key, i);
  }
}
function validate_prop_bindings($$props, bindable, exports, component2) {
  var _a;
  for (const key in $$props) {
    var setter = (_a = get_descriptor($$props, key)) == null ? void 0 : _a.set;
    var name = component2.name;
    if (setter) {
      if (exports.includes(key)) {
        bind_invalid_export(component2.filename, key, name);
      }
      if (!bindable.includes(key)) {
        bind_not_bindable(key, component2.filename, name);
      }
    }
  }
}

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default")
              slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = render_effect(() => {
          var _a;
          this.$$r = true;
          for (const key of object_keys(this.$$c)) {
            if (!((_a = this.$$p_d[key]) == null ? void 0 : _a.reflect))
              continue;
            this.$$d[key] = this.$$c[key];
            const attribute_value = get_custom_element_value(
              key,
              this.$$d[key],
              this.$$p_d,
              "toAttribute"
            );
            if (attribute_value == null) {
              this.removeAttribute(this.$$p_d[key].attribute || key);
            } else {
              this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
            }
          }
          this.$$r = false;
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr = this.$$g_p(attr);
      this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr]: this.$$d[attr] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          destroy_effect(this.$$me);
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop2]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key) => (props_definition[key].attribute || key).toLowerCase()
      );
    }
  };
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        var _a;
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        (_a = this.$$c) == null ? void 0 : _a.$set({ [prop2]: value });
      }
    });
  });
  exports.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        var _a;
        return (_a = this.$$c) == null ? void 0 : _a[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}

export {
  add_locations,
  hmr,
  legacy_api,
  await_block,
  if_block,
  key_block,
  css_props,
  template,
  template_with_script,
  svg_template,
  svg_template_with_script,
  mathml_template,
  text,
  comment,
  append,
  index,
  each,
  html,
  snippet,
  wrap_snippet,
  component,
  element,
  action,
  autofocus,
  remove_textarea_child,
  remove_input_attr_defaults,
  set_attribute,
  set_xlink_attribute,
  set_custom_element_data,
  set_attributes,
  set_dynamic_element_attributes,
  handle_lazy_img,
  set_svg_class,
  set_mathml_class,
  set_class,
  toggle_class,
  set_style,
  animation,
  transition,
  bind_value,
  bind_group,
  bind_checked,
  bind_files,
  bind_current_time,
  bind_buffered,
  bind_seekable,
  bind_played,
  bind_seeking,
  bind_ended,
  bind_ready_state,
  bind_playback_rate,
  bind_paused,
  bind_volume,
  bind_muted,
  bind_online,
  bind_prop,
  select_option,
  init_select,
  bind_select_value,
  bind_resize_observer,
  bind_element_size,
  bind_this,
  bind_content_editable,
  bind_property,
  bind_focused,
  bind_window_scroll,
  bind_window_size,
  trusted,
  self,
  stopPropagation,
  once,
  stopImmediatePropagation,
  preventDefault,
  init,
  update_prop,
  update_pre_prop,
  rest_props,
  legacy_rest_props,
  spread_props,
  prop,
  store_get,
  store_unsub,
  store_set,
  invalidate_store,
  unsubscribe_on_destroy,
  mutate_store,
  update_store,
  update_pre_store,
  validate_dynamic_component,
  validate_each_keys,
  validate_prop_bindings,
  create_custom_element
};
//# sourceMappingURL=chunk-UH3TEY2F.js.map
