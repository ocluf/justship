{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAwBA","sourcesContent":["import type { M } from \"ts-algebra\";\n\nimport type {\n  ExtendedJSONSchema,\n  FromExtendedSchemaOptions,\n  FromSchemaDefaultOptions,\n  FromSchemaOptions,\n  JSONSchema,\n  JSONSchemaExtension,\n  UnextendJSONSchema,\n} from \"./definitions\";\nimport type { ParseOptions } from \"./parse-options\";\nimport type { ParseSchema } from \"./parse-schema\";\n\nexport type {\n  ExtendedJSONSchema,\n  DeserializationPattern,\n  FromSchemaOptions,\n  FromExtendedSchemaOptions,\n  FromSchemaDefaultOptions,\n  JSONSchemaExtension,\n  JSONSchema,\n} from \"./definitions\";\nexport type { $Compiler, Compiler, $Validator, Validator } from \"./utils\";\nexport {\n  wrapCompilerAsTypeGuard,\n  wrapValidatorAsTypeGuard,\n  asConst,\n} from \"./utils\";\n\n/**\n * Given a JSON schema defined with the `as const` statement, infers the type of valid instances\n * @param SCHEMA JSON schema\n */\nexport type FromSchema<\n  SCHEMA extends JSONSchema,\n  OPTIONS extends FromSchemaOptions = FromSchemaDefaultOptions,\n> = M.$Resolve<ParseSchema<SCHEMA, ParseOptions<SCHEMA, OPTIONS>>>;\n\n/**\n * Given an extended JSON schema defined with the `as const` statement, infers the type of valid instances\n * @param SCHEMA JSON schema\n */\nexport type FromExtendedSchema<\n  EXTENSION extends JSONSchemaExtension,\n  SCHEMA extends ExtendedJSONSchema<EXTENSION>,\n  OPTIONS extends\n    FromExtendedSchemaOptions<EXTENSION> = FromSchemaDefaultOptions,\n  UNEXTENDED_SCHEMA = UnextendJSONSchema<EXTENSION, SCHEMA>,\n> = UNEXTENDED_SCHEMA extends JSONSchema\n  ? FromSchema<UNEXTENDED_SCHEMA, OPTIONS>\n  : never;\n"],"file":"index.js"}