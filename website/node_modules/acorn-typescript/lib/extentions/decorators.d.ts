import type { AcornParseClass } from '../middleware';
import type { AcornTypeScript } from '../types';
import type * as acornNamespace from 'acorn';
export default function generateParseDecorators(Parse: typeof AcornParseClass, acornTypeScript: AcornTypeScript, acorn: typeof acornNamespace): {
    new (options: acornNamespace.Options, input: string, startPos?: number): {
        takeDecorators(node: any): void;
        parseDecorators(allowExport?: boolean): void;
        parseDecorator(): any;
        parseMaybeDecoratorArguments(expr: any): any;
        options: acornNamespace.Options & {
            onComment: any;
        };
        pos: number;
        potentialArrowAt: number;
        yieldPos: number;
        value: any;
        containsEsc: boolean;
        decoratorStack: any[];
        awaitPos: number;
        keywords: any;
        awaitIdentPos: number;
        strict: boolean;
        lastTokStart: number;
        lastTokEnd: number;
        treatFunctionsAsVar: boolean;
        inGenerator: any;
        exprAllowed: boolean;
        labels: any[];
        scopeStack: any[];
        undefinedExports: any;
        lastTokEndLoc: any;
        lastTokStartLoc: any;
        context: any[];
        endLoc: any;
        startLoc: any;
        potentialArrowInForAwait: boolean;
        parseImport(node: acornNamespace.Node): any;
        parseImportSpecifier(): any;
        parseExport(node: acornNamespace.Node, exports: any): any;
        parseExportDeclaration(node: acornNamespace.Node): any;
        parseExportSpecifiers(exports: any): any[];
        parseModuleExportName(): any;
        expectContextual(name: string): any;
        semicolon(): any;
        eat(type: acornNamespace.TokenType): boolean;
        checkExport(exports: any, name: any, pos: number): any;
        unexpected(pos?: number): any;
        startNode(): any;
        startNodeAt(pos: number, loc: any): any;
        isAsyncFunction(): boolean;
        checkVariableExport(exports: any, decls: any): any;
        checkUnreserved(options: {
            start: number;
            end: number;
            name: string;
        }): any;
        checkLocalExport(id: any): any;
        parseMaybeDefault(startPos: number, startLoc: any, left: any): any;
        finishOp(type: acornNamespace.TokenType, size: number): any;
        getTokenFromCode(code: number): acornNamespace.TokenType;
        readToken_lt_gt(code: number): acornNamespace.TokenType;
        fullCharCodeAtPos(): number;
        canInsertSemicolon(): boolean;
        parseFunctionParams(node: any): void;
        expect(type: acornNamespace.TokenType): void;
        readWord1(): string;
        parseArrowExpression(node: any, param: any, isAsync?: boolean, forInit?: boolean): any;
        curContext(): any;
        updateContext(prevType: acornNamespace.TokenType): any;
        isContextual(name: string): boolean;
        eatContextual(name: any): boolean;
        parseLiteral(value: string): any;
        checkLValSimple(expr: any, bindingType?: number, checkClashes?: any): any;
        enterScope(flags: any): void;
        exitScope(): void;
        parseFunctionStatement(node: any, isAsync?: boolean, declarationPosition?: any): any;
        parseObj(isPattern?: boolean, refDestructuringErrors?: any): any;
        parseBindingList(close: acornNamespace.TokenType, allowEmpty?: boolean, allowTrailingComma?: boolean, allowModifiers?: boolean): any;
        parsePropertyName(prop: any): any;
        isLet(context?: any): boolean;
        parseTemplateElement({ isTagged }: {
            isTagged: boolean;
        }): any;
        parseExpression(forInit?: boolean, refDestructuringErrors?: any): any;
        initFunction(node: any): void;
        parseFunctionBody(node: any, isArrowFunction?: boolean, isMethod?: boolean, forInit?: boolean): any;
        parseSubscripts(base: any, startPos: number, startLoc: acornNamespace.Position, noCalls?: any, forInit?: any): any;
        parseExprList(close: acornNamespace.TokenType, allowTrailingComma?: any, allowEmpty?: any, refDestructuringErrors?: any): any;
        parseExprOp(left: any, leftStartPos: number, leftStartLoc: acornNamespace.Position, minPrec?: any, forInit?: any): any;
        toAssignableList(exprList: any[], isBinding?: boolean): any;
        parseMaybeUnary(refExpressionErrors?: any, sawUnary?: boolean, incDec?: boolean, forInit?: boolean): any;
        readRegexp(): any;
        overrideContext(ctx: any): any;
        isSimpleAssignTarget(expr: any): boolean;
        parseExprImport(forNew?: boolean): any;
        next(ignoreEscapeSequenceInKeyword?: boolean): any;
        parseStatement(context: any, topLevel?: boolean, exports?: any): any;
        parseExpressionStatement(node: any, expre: any): any;
        shouldParseExportStatement(): boolean;
        parseExprOps(forInit?: boolean, refDestructuringErrors?: any): any;
        checkExpressionErrors(refDestructuringErrors: any, andThrow?: boolean): any;
        parseParenItem(item: any): any;
        parseClassId(node: any, isStatement?: boolean | "nullableID"): any;
        parseClassField(field: any): any;
        parseClassStaticBlock(node: any): any;
        isClassElementNameStart(): boolean;
        parseClassElementName(element: any): any;
        parseClassSuper(node: any): any;
        parseVarId(decl: any, kind: "var" | "let" | "const"): any;
        parseMaybeAssign(forInit?: boolean, refDestructuringErrors?: any, afterLeftParse?: any): any;
        toAssignable(node: any, isBinding?: boolean, refDestructuringErrors?: any): any;
        curPosition(): acornNamespace.Position;
        checkPatternErrors(refDestructuringErrors?: any, isAssign?: boolean): any;
        parseExprSubscripts(refDestructuringErrors?: any, forInit?: boolean): any;
        checkYieldAwaitInDefaultParams(): any;
        parseParenExpression(): any;
        parseBindingAtom(): any;
        afterTrailingComma(tokType: acornNamespace.TokenType, notNext?: boolean): any;
        parsePrivateIdent(): any;
        parseRestBinding: any;
        parseBlock(createNewLexicalScope?: boolean, node?: any, exitStrict?: boolean): any;
        enterClassBody(): any;
        exitClassBody(): any;
        parseIdent(liberal?: boolean): any;
        copyNode(node: any): any;
        checkLValPattern(expr: any, bindingType?: number, checkClashes?: any): any;
        isAsyncProp(prop: any): boolean;
        shouldParseArrow(): boolean;
        parseYield(forInit?: any): any;
        parseProperty(isPattern?: boolean, refDestructuringErrors?: any): any;
        resetStartLocationFromNode(node: acornNamespace.Node, locationNode: acornNamespace.Node): void;
        match(type: acornNamespace.TokenType): boolean;
        canHaveLeadingDecorator(): boolean;
        startNodeAtNode(type: acornNamespace.Node): any;
        readToken(code: number): any;
        jsx_readToken(): any;
        jsx_readString(quote: any): any;
        jsx_parseText(): any;
        jsx_parseElement(): any;
        jsx_readWord(): any;
        jsx_parseElementName(): any;
        jsx_parseAttribute(): any;
        finishToken(token: acornNamespace.TokenType, val?: string): any;
        parseExprAtom(refDestructuringErrors?: any, forInit?: boolean, forNew?: boolean): any;
        lineStart: number;
        curLine: number;
        start: number;
        end: number;
        input: string;
        type: acornNamespace.TokenType;
        parse(this: acornNamespace.Parser): acornNamespace.Node;
        nextToken(): void;
        parseTopLevel(node: acornNamespace.Node): acornNamespace.Node;
        finishNode(node: acornNamespace.Node, type: string): acornNamespace.Node;
        finishNodeAt(node: acornNamespace.Node, type: string, pos: number, loc: acornNamespace.Position): acornNamespace.Node;
        raise(pos: number, message: string): void;
        raiseRecoverable?(pos: number, message: string): void;
    };
    acorn: typeof acornNamespace;
    parse(this: typeof acornNamespace.Parser, input: string, options: acornNamespace.Options): acornNamespace.Node;
    parseExpressionAt(this: typeof acornNamespace.Parser, input: string, pos: number, options: acornNamespace.Options): acornNamespace.Node;
    tokenizer(this: typeof acornNamespace.Parser, input: string, options: acornNamespace.Options): {
        getToken(): acornNamespace.Token;
        [Symbol.iterator](): Iterator<acornNamespace.Token, any, undefined>;
    };
    extend(this: typeof acornNamespace.Parser, ...plugins: ((BaseParser: typeof acornNamespace.Parser) => typeof acornNamespace.Parser)[]): typeof acornNamespace.Parser;
};
