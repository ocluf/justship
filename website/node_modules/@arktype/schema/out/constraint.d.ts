import { type array, type describeExpression, type listable, type satisfy } from "@arktype/util";
import type { Inner, Node, NodeSchema, Prerequisite, innerAttachedAs } from "./kinds.js";
import { BaseNode } from "./node.js";
import type { NodeParseContext } from "./parse.js";
import type { IntersectionInner, MutableIntersectionInner } from "./roots/intersection.js";
import type { BaseRoot, Root, UnknownRoot } from "./roots/root.js";
import type { NodeCompiler } from "./shared/compile.js";
import type { RawNodeDeclaration } from "./shared/declare.js";
import { Disjoint } from "./shared/disjoint.js";
import { type ConstraintKind, type IntersectionContext, type NodeKind, type RootKind, type StructuralKind, type kindLeftOf } from "./shared/implement.js";
import type { TraverseAllows, TraverseApply } from "./shared/traversal.js";
import { arkKind } from "./shared/utils.js";
export interface BaseConstraintDeclaration extends RawNodeDeclaration {
    kind: ConstraintKind;
}
export declare abstract class BaseConstraint<
/** uses -ignore rather than -expect-error because this is not an error in .d.ts
 * @ts-ignore allow instantiation assignment to the base type */
out d extends BaseConstraintDeclaration = BaseConstraintDeclaration> extends BaseNode<d> {
    readonly [arkKind] = "constraint";
    abstract readonly impliedBasis: BaseRoot | null;
    readonly impliedSiblings?: array<BaseConstraint>;
    intersect<r extends BaseConstraint>(r: r): intersectConstraintKinds<d["kind"], r["kind"]>;
}
export type ConstraintReductionResult = BaseRoot | Disjoint | MutableIntersectionInner;
export declare abstract class RawPrimitiveConstraint<d extends BaseConstraintDeclaration> extends BaseConstraint<d> {
    abstract traverseAllows: TraverseAllows<d["prerequisite"]>;
    abstract readonly compiledCondition: string;
    abstract readonly compiledNegation: string;
    traverseApply: TraverseApply<d["prerequisite"]>;
    compile(js: NodeCompiler): void;
    get errorContext(): d["errorContext"];
    get compiledErrorContext(): string;
}
export declare const constraintKeyParser: <kind extends "regex" | "divisor" | "exactLength" | "max" | "min" | "maxLength" | "minLength" | "before" | "after" | "required" | "optional" | "index" | "sequence" | "structure" | "predicate">(kind: kind) => (schema: listable<NodeSchema<kind>>, ctx: NodeParseContext) => innerAttachedAs<kind> | undefined;
type ConstraintGroupKind = satisfy<NodeKind, "intersection" | "structure">;
interface ConstraintIntersectionState<kind extends ConstraintGroupKind = ConstraintGroupKind> {
    kind: kind;
    baseInner: Record<string, unknown>;
    l: BaseConstraint[];
    r: BaseConstraint[];
    roots: BaseRoot[];
    ctx: IntersectionContext;
}
export declare const intersectConstraints: <kind extends "intersection" | "structure">(s: ConstraintIntersectionState<kind>) => Node<RootKind | Extract<kind, "structure">> | Disjoint;
export declare const flattenConstraints: (inner: object) => BaseConstraint[];
export declare const unflattenConstraints: (constraints: array<BaseConstraint>) => IntersectionInner & Inner<"structure">;
export type constraintKindLeftOf<kind extends ConstraintKind> = ConstraintKind & kindLeftOf<kind>;
export type constraintKindOrLeftOf<kind extends ConstraintKind> = kind | constraintKindLeftOf<kind>;
export type intersectConstraintKinds<l extends ConstraintKind, r extends ConstraintKind> = Node<l | r | "unit" | "union"> | Disjoint | null;
export declare const throwInvalidOperandError: (kind: "regex" | "divisor" | "exactLength" | "max" | "min" | "maxLength" | "minLength" | "before" | "after" | "required" | "optional" | "index" | "sequence" | "structure" | "predicate", expected: Root<unknown, any>, actual: Root<unknown, any>) => never;
export declare const writeInvalidOperandMessage: <kind extends "regex" | "divisor" | "exactLength" | "max" | "min" | "maxLength" | "minLength" | "before" | "after" | "required" | "optional" | "index" | "sequence" | "structure" | "predicate", expected extends Root<unknown, any>, actual extends Root<unknown, any>>(kind: kind, expected: expected, actual: actual) => `${Capitalize<kind>} operand must be ${import("@arktype/util").join<import("@arktype/util").unionToTuple<import("@arktype/util").isAny<Prerequisite<kind>> extends true ? "any" : import("@arktype/util").isNever<Prerequisite<kind>> extends true ? "never" : unknown extends Prerequisite<kind> ? "unknown" : Prerequisite<kind> extends infer T ? T extends Prerequisite<kind> ? T extends object ? import("@arktype/util").describeObject<T> : T extends import("@arktype/util").Stringifiable ? import("@arktype/util").inferDomain<import("@arktype/util").domainOf<T>> extends T ? import("@arktype/util").join<import("@arktype/util").unionToTuple<{
    boolean: "boolean";
    null: "null";
    undefined: "undefined";
    bigint: "a bigint";
    number: "a number";
    object: "an object";
    string: "a string";
    symbol: "a symbol";
}[import("@arktype/util").domainOf<T>]>, " or ", ""> : `${T}` : import("@arktype/util").join<import("@arktype/util").unionToTuple<{
    boolean: "boolean";
    null: "null";
    undefined: "undefined";
    bigint: "a bigint";
    number: "a number";
    object: "an object";
    string: "a string";
    symbol: "a symbol";
}[import("@arktype/util").domainOf<T>]>, " or ", ""> : never : never>, " | ", "">} (was ${import("@arktype/util").join<import("@arktype/util").unionToTuple<import("@arktype/util").isAny<Exclude<actual["infer"], Prerequisite<kind>>> extends true ? "any" : import("@arktype/util").isNever<Exclude<actual["infer"], Prerequisite<kind>>> extends true ? "never" : unknown extends Exclude<actual["infer"], Prerequisite<kind>> ? "unknown" : Exclude<actual["infer"], Prerequisite<kind>> extends infer T_1 ? T_1 extends Exclude<actual["infer"], Prerequisite<kind>> ? T_1 extends object ? import("@arktype/util").describeObject<T_1> : T_1 extends import("@arktype/util").Stringifiable ? import("@arktype/util").inferDomain<import("@arktype/util").domainOf<T_1>> extends T_1 ? import("@arktype/util").join<import("@arktype/util").unionToTuple<{
    boolean: "boolean";
    null: "null";
    undefined: "undefined";
    bigint: "a bigint";
    number: "a number";
    object: "an object";
    string: "a string";
    symbol: "a symbol";
}[import("@arktype/util").domainOf<T_1>]>, " or ", ""> : `${T_1}` : import("@arktype/util").join<import("@arktype/util").unionToTuple<{
    boolean: "boolean";
    null: "null";
    undefined: "undefined";
    bigint: "a bigint";
    number: "a number";
    object: "an object";
    string: "a string";
    symbol: "a symbol";
}[import("@arktype/util").domainOf<T_1>]>, " or ", ""> : never : never>, " | ", "">})`;
export type writeInvalidOperandMessage<kind extends ConstraintKind, actual extends Root> = `${Capitalize<kind>} operand must be ${describeExpression<Prerequisite<kind>>} (was ${describeExpression<Exclude<actual["infer"], Prerequisite<kind>>>})`;
export interface ConstraintAttachments {
    impliedBasis: UnknownRoot | null;
    impliedSiblings?: array<BaseConstraint> | null;
}
export type PrimitiveConstraintKind = Exclude<ConstraintKind, StructuralKind>;
export {};
