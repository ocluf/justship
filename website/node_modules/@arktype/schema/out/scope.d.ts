import { DynamicBase, type Json, type array, type flattenListable, type requireKeys, type show } from "@arktype/util";
import { type GenericRoot } from "./generic.js";
import type { inferRoot, validateRoot } from "./inference.js";
import type { internalKeywords } from "./keywords/internal.js";
import type { jsObjects } from "./keywords/jsObjects.js";
import type { Ark } from "./keywords/keywords.js";
import type { tsKeywords } from "./keywords/tsKeywords.js";
import { type Node, type NodeSchema, type RootSchema, type reducibleKindOf } from "./kinds.js";
import { type PreparsedNodeResolution, type SchemaModule } from "./module.js";
import type { BaseNode } from "./node.js";
import { type NodeParseOptions } from "./parse.js";
import { type AliasNode } from "./roots/alias.js";
import type { BaseRoot, Root } from "./roots/root.js";
import type { ActualWriter, ArkErrorCode, ExpectedWriter, MessageWriter, ProblemWriter } from "./shared/errors.js";
import type { DescriptionWriter, NodeKind, RootKind } from "./shared/implement.js";
import { arkKind, type internalImplementationOf } from "./shared/utils.js";
export type nodeResolutions<keywords> = {
    [k in keyof keywords]: BaseRoot;
};
export type BaseResolutions = Record<string, BaseRoot>;
declare global {
    export interface StaticArkConfig {
        preserve(): never;
        ambient(): Ark;
    }
}
export type ambient = ReturnType<StaticArkConfig["ambient"]>;
type nodeConfigForKind<kind extends NodeKind> = Readonly<show<{
    description?: DescriptionWriter<kind>;
} & (kind extends ArkErrorCode ? {
    expected?: ExpectedWriter<kind>;
    actual?: ActualWriter<kind>;
    problem?: ProblemWriter<kind>;
    message?: MessageWriter<kind>;
} : {})>>;
type NodeConfigsByKind = {
    [kind in NodeKind]: nodeConfigForKind<kind>;
};
export type NodeConfig<kind extends NodeKind = NodeKind> = NodeConfigsByKind[kind];
type UnknownNodeConfig = {
    description?: DescriptionWriter;
    expected?: ExpectedWriter;
    actual?: ActualWriter;
    problem?: ProblemWriter;
    message?: MessageWriter;
};
export type ParsedUnknownNodeConfig = requireKeys<UnknownNodeConfig, "description">;
export type StaticArkOption<k extends keyof StaticArkConfig> = ReturnType<StaticArkConfig[k]>;
export interface ArkConfig extends Partial<Readonly<NodeConfigsByKind>> {
    jitless?: boolean;
}
type resolveConfig<config extends ArkConfig> = {
    [k in keyof config]-?: k extends NodeKind ? Required<config[k]> : config[k];
};
export type ResolvedArkConfig = resolveConfig<ArkConfig>;
export declare const defaultConfig: ResolvedArkConfig;
export declare const extendConfig: (base: ArkConfig, extension: ArkConfig | undefined) => ArkConfig;
export declare const resolveConfig: (config: ArkConfig | undefined) => ResolvedArkConfig;
export type RawRootResolutions = Record<string, RawResolution | undefined>;
export type exportedNameOf<$> = Exclude<keyof $ & string, PrivateDeclaration>;
export type PrivateDeclaration<key extends string = string> = `#${key}`;
type toRawScope<$> = RawRootScope<{
    [k in keyof $]: $[k] extends {
        [arkKind]: infer kind;
    } ? kind extends "generic" ? GenericRoot : kind extends "module" ? RawRootModule : never : BaseRoot;
}>;
export type PrimitiveKeywords = typeof tsKeywords & typeof jsObjects & typeof internalKeywords;
export type RawResolution = BaseRoot | GenericRoot | RawRootModule;
type CachedResolution = string | RawResolution;
export declare const writeDuplicateAliasError: <alias extends string>(alias: alias) => `#${alias} duplicates public alias ${alias}`;
export type writeDuplicateAliasError<alias extends string> = `#${alias} duplicates public alias ${alias}`;
export declare class RawRootScope<$ extends RawRootResolutions = RawRootResolutions> implements internalImplementationOf<RootScope, "t"> {
    readonly config: ArkConfig;
    readonly resolvedConfig: ResolvedArkConfig;
    readonly id: string;
    readonly [arkKind] = "scope";
    readonly referencesById: {
        [name: string]: BaseNode;
    };
    references: readonly BaseNode[];
    protected readonly resolutions: {
        [alias: string]: CachedResolution | undefined;
    };
    readonly json: Json;
    exportedNames: string[];
    readonly aliases: Record<string, unknown>;
    protected resolved: boolean;
    static ambient: RawRootScope;
    get ambient(): RawRootScope;
    constructor(
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    def: Record<string, unknown>, config?: ArkConfig);
    get raw(): this;
    schema(def: RootSchema, opts?: NodeParseOptions): BaseRoot;
    defineRoot(def: RootSchema): RootSchema;
    units(values: array, opts?: NodeParseOptions): BaseRoot;
    protected lazyResolutions: AliasNode[];
    lazilyResolve(resolve: () => BaseRoot, syntheticAlias?: string): AliasNode;
    node: <kinds extends NodeKind | array<RootKind>, prereduced extends boolean = false>(kinds: kinds, nodeSchema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions<prereduced>) => Node<prereduced extends true ? flattenListable<kinds> : reducibleKindOf<flattenListable<kinds>>>;
    parseRoot(def: unknown, opts?: NodeParseOptions): BaseRoot;
    resolveRoot(name: string): BaseRoot;
    maybeResolveRoot(name: string): BaseRoot | undefined;
    maybeResolveGenericOrRoot(name: string): BaseRoot | GenericRoot | undefined;
    preparseRoot(def: unknown): unknown;
    maybeResolve(name: string): RawResolution | undefined;
    maybeShallowResolve(name: string): CachedResolution | undefined;
    /** If name is a valid reference to a submodule alias, return its resolution  */
    protected maybeResolveSubalias(name: string): BaseRoot | GenericRoot | undefined;
    import<names extends exportedNameOf<$>[]>(...names: names): show<destructuredImportContext<$, names>>;
    private _exportedResolutions;
    private _exports;
    export<names extends exportedNameOf<$>[]>(...names: names): show<destructuredExportContext<$, names>>;
    resolve<name extends exportedNameOf<$>>(name: name): destructuredExportContext<$, []>[name];
}
export type validateAliases<aliases> = {
    [k in keyof aliases]: aliases[k] extends PreparsedNodeResolution ? aliases[k] : validateRoot<aliases[k], aliases>;
};
export type instantiateAliases<aliases> = {
    [k in keyof aliases]: aliases[k] extends PreparsedNodeResolution ? aliases[k] : inferRoot<aliases[k], aliases>;
} & unknown;
export declare const schemaScope: <const aliases>(aliases: validateAliases<aliases>, config?: ArkConfig) => RootScope<{ [k in keyof aliases]: aliases[k] extends PreparsedNodeResolution ? aliases[k] : inferRoot<aliases[k], aliases>; }>;
export interface RootScope<$ = any> {
    t: $;
    [arkKind]: "scope";
    config: ArkConfig;
    references: readonly BaseNode[];
    json: Json;
    exportedNames: array<exportedNameOf<$>>;
    /** The set of names defined at the root-level of the scope mapped to their
     * corresponding definitions.**/
    aliases: Record<string, unknown>;
    raw: toRawScope<$>;
    schema<const def extends RootSchema>(schema: def, opts?: NodeParseOptions): Root<inferRoot<def, $>, $>;
    defineRoot<const def extends RootSchema>(schema: def): def;
    units<const branches extends array>(values: branches, opts?: NodeParseOptions): Root<branches[number], $>;
    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: NodeParseOptions): Node<reducibleKindOf<flattenListable<kinds>>>;
    parseRoot(schema: unknown, opts?: NodeParseOptions): BaseRoot;
    import<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredImportContext<$, names>>>;
    export<names extends exportedNameOf<$>[]>(...names: names): SchemaModule<show<destructuredExportContext<$, names>>>;
    resolve<name extends exportedNameOf<$>>(name: name): $[name] extends PreparsedNodeResolution ? $[name] : Root<$[name], $>;
}
export declare const RootScope: new <$ = any>(...args: ConstructorParameters<typeof RawRootScope>) => RootScope<$>;
export declare const root: RootScope<{}>;
export declare const schema: RootScope["schema"];
export declare const node: RootScope["node"];
export declare const defineRoot: RootScope["defineRoot"];
export declare const units: RootScope["units"];
export declare const rawRoot: RawRootScope["schema"];
export declare const rawNode: RawRootScope["node"];
export declare const defineRawRoot: RawRootScope["defineRoot"];
export declare const rawUnits: RawRootScope["units"];
export declare class RawRootModule<resolutions extends RawRootResolutions = RawRootResolutions> extends DynamicBase<resolutions> {
    readonly [arkKind]: "module";
}
export type destructuredExportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names extends [] ? exportedNameOf<$> : names[number]]: $[k];
};
export type destructuredImportContext<$, names extends exportedNameOf<$>[]> = {
    [k in names extends [] ? exportedNameOf<$> : names[number] as `#${k & string}`]: $[k];
};
export type RootExportCache = Record<string, BaseRoot | GenericRoot | RawRootModule | undefined>;
export declare const writeUnresolvableMessage: <token extends string>(token: token) => `'${token}' is unresolvable`;
export type writeUnresolvableMessage<token extends string> = `'${token}' is unresolvable`;
export declare const writeNonSubmoduleDotMessage: <name extends string>(name: name) => `'${name}' must reference a module to be accessed using dot syntax`;
export type writeNonSubmoduleDotMessage<name extends string> = `'${name}' must reference a module to be accessed using dot syntax`;
export declare const writeMissingSubmoduleAccessMessage: <name extends string>(name: name) => `Reference to submodule '${name}' must specify an alias`;
export type writeMissingSubmoduleAccessMessage<name extends string> = `Reference to submodule '${name}' must specify an alias`;
export declare const bindCompiledScope: (references: readonly BaseNode[]) => void;
export {};
