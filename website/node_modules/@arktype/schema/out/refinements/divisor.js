import { RawPrimitiveConstraint, writeInvalidOperandMessage } from "../constraint.js";
import { implementNode } from "../shared/implement.js";
export const divisorImplementation = implementNode({
    kind: "divisor",
    collapsibleKey: "rule",
    keys: {
        rule: {}
    },
    normalize: schema => typeof schema === "number" ? { rule: schema } : schema,
    hasAssociatedError: true,
    defaults: {
        description: node => node.rule === 1 ? "an integer" : `a multiple of ${node.rule}`
    },
    intersections: {
        divisor: (l, r, ctx) => ctx.$.node("divisor", {
            rule: Math.abs((l.rule * r.rule) / greatestCommonDivisor(l.rule, r.rule))
        })
    }
});
export class DivisorNode extends RawPrimitiveConstraint {
    traverseAllows = data => data % this.rule === 0;
    compiledCondition = `data % ${this.rule} === 0`;
    compiledNegation = `data % ${this.rule} !== 0`;
    impliedBasis = this.$.keywords.number.raw;
    expression = `% ${this.rule}`;
}
export const writeIndivisibleMessage = (t) => writeInvalidOperandMessage("divisor", t.$.raw.keywords.number, t);
// https://en.wikipedia.org/wiki/Euclidean_algorithm
const greatestCommonDivisor = (l, r) => {
    let previous;
    let greatestCommonDivisor = l;
    let current = r;
    while (current !== 0) {
        previous = current;
        current = greatestCommonDivisor % current;
        greatestCommonDivisor = previous;
    }
    return greatestCommonDivisor;
};
