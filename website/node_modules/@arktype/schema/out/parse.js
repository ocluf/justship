import { entriesOf, hasDomain, isArray, printable, throwParseError, unset } from "@arktype/util";
import { nodeClassesByKind, nodeImplementationsByKind } from "./kinds.js";
import { Disjoint } from "./shared/disjoint.js";
import { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from "./shared/implement.js";
import { hasArkKind } from "./shared/utils.js";
const baseKeys = {
    description: { meta: true }
};
export const schemaKindOf = (schema, allowedKinds) => {
    const kind = discriminateRootKind(schema);
    if (allowedKinds && !allowedKinds.includes(kind)) {
        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);
    }
    return kind;
};
const discriminateRootKind = (schema) => {
    switch (typeof schema) {
        case "string":
            return schema[0] === "$" ? "alias" : "domain";
        case "function":
            return hasArkKind(schema, "root") ? schema.kind : "proto";
        case "object": {
            // throw at end of function
            if (schema === null)
                break;
            if ("morphs" in schema)
                return "morph";
            if ("branches" in schema || isArray(schema))
                return "union";
            if ("unit" in schema)
                return "unit";
            if ("alias" in schema)
                return "alias";
            const schemaKeys = Object.keys(schema);
            if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))
                return "intersection";
            if ("proto" in schema)
                return "proto";
            if ("domain" in schema)
                return "domain";
        }
    }
    return throwParseError(`${printable(schema)} is not a valid type schema`);
};
const nodeCache = {};
const serializeListableChild = (listableNode) => isArray(listableNode) ?
    listableNode.map(node => node.collapsibleJson)
    : listableNode.collapsibleJson;
export const parseNode = (kind, ctx) => {
    const impl = nodeImplementationsByKind[kind];
    const inner = {};
    // ensure node entries are parsed in order of precedence, with non-children
    // parsed first
    const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ?
        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)
            : 1
        : isNodeKind(rKey) ? -1
            : lKey < rKey ? -1
                : 1);
    const children = [];
    for (const entry of schemaEntries) {
        const k = entry[0];
        const keyImpl = impl.keys[k] ?? baseKeys[k];
        if (!keyImpl)
            return throwParseError(`Key ${k} is not valid on ${kind} schema`);
        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];
        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))
            inner[k] = v;
    }
    const entries = entriesOf(inner);
    let json = {};
    let typeJson = {};
    entries.forEach(([k, v]) => {
        const listableNode = v;
        const keyImpl = impl.keys[k] ?? baseKeys[k];
        const serialize = keyImpl.serialize ??
            (keyImpl.child ? serializeListableChild : defaultValueSerializer);
        json[k] = serialize(listableNode);
        if (keyImpl.child) {
            if (isArray(listableNode))
                children.push(...listableNode);
            else
                children.push(listableNode);
        }
        if (!keyImpl.meta)
            typeJson[k] = json[k];
    });
    if (impl.finalizeJson) {
        json = impl.finalizeJson(json);
        typeJson = impl.finalizeJson(typeJson);
    }
    let collapsibleJson = json;
    const collapsibleKeys = Object.keys(collapsibleJson);
    if (collapsibleKeys.length === 1 &&
        collapsibleKeys[0] === impl.collapsibleKey) {
        collapsibleJson = collapsibleJson[impl.collapsibleKey];
        if (
        // if the collapsibleJson is still an object
        hasDomain(collapsibleJson, "object") &&
            // and the JSON did not include any implied keys
            Object.keys(json).length === 1) {
            // we can replace it with its collapsed value
            json = collapsibleJson;
            typeJson = collapsibleJson;
        }
    }
    const innerHash = JSON.stringify({ kind, ...json });
    if (ctx.reduceTo) {
        nodeCache[innerHash] = ctx.reduceTo;
        return ctx.reduceTo;
    }
    const typeHash = JSON.stringify({ kind, ...typeJson });
    if (impl.reduce && !ctx.prereduced) {
        const reduced = impl.reduce(inner, ctx.$);
        if (reduced) {
            if (reduced instanceof Disjoint)
                return reduced.throw();
            // if we're defining the resolution of an alias and the result is
            // reduced to another node, add the alias to that node if it doesn't
            // already have one.
            if (ctx.alias)
                reduced.alias ??= ctx.alias;
            // we can't cache this reduction for now in case the reduction involved
            // impliedSiblings
            return reduced;
        }
    }
    // we have to wait until after reduction to return a cached entry,
    // since reduction can add impliedSiblings
    if (nodeCache[innerHash])
        return nodeCache[innerHash];
    const attachments = {
        id: ctx.id,
        kind,
        impl,
        inner,
        entries,
        json: json,
        typeJson: typeJson,
        collapsibleJson: collapsibleJson,
        children,
        innerHash,
        typeHash,
        $: ctx.$
    };
    if (ctx.alias)
        attachments.alias = ctx.alias;
    for (const k in inner) {
        if (k !== "description" && k !== "in" && k !== "out")
            attachments[k] = inner[k];
    }
    const node = new nodeClassesByKind[kind](attachments);
    nodeCache[innerHash] = node;
    return node;
};
