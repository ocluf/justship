import { ArkError, ArkErrors } from "./errors.js";
export class TraversalContext {
    root;
    config;
    path = [];
    queuedMorphs = [];
    errors = new ArkErrors(this);
    branches = [];
    seen = {};
    constructor(root, config) {
        this.root = root;
        this.config = config;
    }
    get currentBranch() {
        return this.branches.at(-1);
    }
    queueMorphs(morphs) {
        const input = {
            path: [...this.path],
            morphs
        };
        this.currentBranch?.queuedMorphs.push(input) ??
            this.queuedMorphs.push(input);
    }
    finalize() {
        if (this.hasError())
            return this.errors;
        if (this.queuedMorphs.length) {
            for (let i = 0; i < this.queuedMorphs.length; i++) {
                const { path, morphs } = this.queuedMorphs[i];
                const key = path.at(-1);
                let parent;
                if (key !== undefined) {
                    // find the object on which the key to be morphed exists
                    parent = this.root;
                    for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)
                        parent = parent[path[pathIndex]];
                }
                this.path = path;
                for (const morph of morphs) {
                    const result = morph(parent === undefined ? this.root : parent[key], this);
                    if (result instanceof ArkErrors)
                        return result;
                    if (this.hasError())
                        return this.errors;
                    if (result instanceof ArkError) {
                        // if an ArkError was returned but wasn't added to these
                        // errors, add it then return
                        this.error(result);
                        return this.errors;
                    }
                    // apply the morph function and assign the result to the
                    // corresponding property, or to root if path is empty
                    if (parent === undefined)
                        this.root = result;
                    else
                        parent[key] = result;
                }
            }
        }
        return this.root;
    }
    get currentErrorCount() {
        return (this.currentBranch ?
            this.currentBranch.error ?
                1
                : 0
            : this.errors.count);
    }
    hasError() {
        return this.currentErrorCount !== 0;
    }
    get failFast() {
        return this.branches.length !== 0;
    }
    error(input) {
        const errCtx = typeof input === "object" ?
            input.code ?
                input
                : { ...input, code: "predicate" }
            : { code: "predicate", expected: input };
        const error = new ArkError(errCtx, this);
        if (this.currentBranch)
            this.currentBranch.error = error;
        else
            this.errors.add(error);
        return error;
    }
    get data() {
        let result = this.root;
        for (const segment of this.path)
            result = result?.[segment];
        return result;
    }
    invalid(input) {
        this.error(input);
        return false;
    }
    pushBranch() {
        this.branches.push({
            error: undefined,
            queuedMorphs: []
        });
    }
    popBranch() {
        return this.branches.pop();
    }
}
