import { Hkt } from "@arktype/util";
import { Disjoint } from "./disjoint.js";
import { isNode } from "./utils.js";
const intersectionCache = {};
export const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: false });
export const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: true });
export const intersectNodes = (l, r, ctx) => {
    const operator = ctx.pipe ? "|>" : "&";
    const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;
    if (intersectionCache[lrCacheKey] !== undefined)
        return intersectionCache[lrCacheKey];
    if (!ctx.pipe) {
        // we can only use this for the commutative & operator
        const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;
        if (intersectionCache[rlCacheKey] !== undefined) {
            // if the cached result was a Disjoint and the operands originally
            // appeared in the opposite order, we need to invert it to match
            const rlResult = intersectionCache[rlCacheKey];
            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;
            // add the lr result to the cache directly to bypass this check in the future
            intersectionCache[lrCacheKey] = lrResult;
            return lrResult;
        }
    }
    if (l.equals(r))
        return l;
    let result;
    if (ctx.pipe && l.hasKind("morph")) {
        result =
            ctx.invert ?
                pipeToMorph(r, l, ctx)
                : pipeFromMorph(l, r, ctx);
    }
    else if (ctx.pipe && r.hasKind("morph")) {
        result =
            ctx.invert ?
                pipeFromMorph(r, l, ctx)
                : pipeToMorph(l, r, ctx);
    }
    else {
        const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;
        const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];
        result =
            implementation === undefined ?
                // should be two ConstraintNodes that have no relation
                // this could also happen if a user directly intersects a Type and a ConstraintNode,
                // but that is not allowed by the external function signature
                null
                : leftmostKind === l.kind ? implementation(l, r, ctx)
                    : implementation(r, l, { ...ctx, invert: !ctx.invert });
    }
    if (isNode(result)) {
        // if the result equals one of the operands, preserve its metadata by
        // returning the original reference
        if (l.equals(result))
            result = l;
        else if (r.equals(result))
            result = r;
    }
    intersectionCache[lrCacheKey] = result;
    return result;
};
// TODO: double check pipes through chained morphs
export const pipeFromMorph = (from, to, ctx) => {
    const morphs = [...from.morphs];
    if (from.validatedOut) {
        // still piped from context, so allows appending additional morphs
        const outIntersection = intersectNodes(from.validatedOut, to, ctx);
        if (outIntersection instanceof Disjoint)
            return outIntersection;
        morphs[morphs.length - 1] = outIntersection;
    }
    else
        morphs.push(to);
    return ctx.$.node("morph", {
        morphs,
        in: from.in
    });
};
export const pipeToMorph = (from, to, ctx) => {
    const result = intersectNodes(from, to.in, ctx);
    if (result instanceof Disjoint)
        return result;
    return ctx.$.node("morph", {
        morphs: to.morphs,
        in: result
    });
};
