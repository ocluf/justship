import { type array, type mutable, type show } from "@arktype/util";
import type { BaseConstraint } from "../constraint.js";
import type { GenericRoot } from "../generic.js";
import type { BaseNode } from "../node.js";
import type { BaseRoot } from "../roots/root.js";
import type { RawRootModule, RawRootScope } from "../scope.js";
import type { ArkError } from "./errors.js";
export declare const makeRootAndArrayPropertiesMutable: <o extends object>(o: o) => { -readonly [k in keyof o]: o[k] extends array | undefined ? o[k] extends infer T ? T extends o[k] ? T extends object ? T extends (...args: never[]) => unknown ? T : { -readonly [k_1 in keyof T]: T[k_1]; } : T : never : never : o[k]; };
export type makeRootAndArrayPropertiesMutable<inner> = {
    -readonly [k in keyof inner]: inner[k] extends array | undefined ? mutable<inner[k]> : inner[k];
} & unknown;
export type internalImplementationOf<external, typeOnlyKey extends keyof external = never> = {
    [k in Exclude<keyof external, typeOnlyKey>]: external[k] extends ((...args: infer args) => unknown) ? (...args: {
        [i in keyof args]: never;
    }) => unknown : unknown;
};
export type TraversalPath = PropertyKey[];
export declare const pathToPropString: (path: TraversalPath) => string;
export declare const arkKind: unique symbol;
export interface ArkKinds {
    constraint: BaseConstraint;
    root: BaseRoot;
    scope: RawRootScope;
    generic: GenericRoot;
    module: RawRootModule;
    error: ArkError;
}
export type ArkKind = show<keyof ArkKinds>;
export declare const hasArkKind: <kind extends ArkKind>(value: unknown, kind: kind) => value is ArkKinds[kind];
export declare const isNode: (value: unknown) => value is BaseNode<import("./declare.js").RawNodeDeclaration>;
export declare const inferred: unique symbol;
