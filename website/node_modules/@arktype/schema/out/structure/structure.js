var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
import { append, cached, flatMorph, registeredReference, spliterate } from "@arktype/util";
import { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from "../constraint.js";
import { Disjoint } from "../shared/disjoint.js";
import { implementNode } from "../shared/implement.js";
import { intersectNodesRoot } from "../shared/intersections.js";
import { makeRootAndArrayPropertiesMutable } from "../shared/utils.js";
import { arrayIndexMatcher, arrayIndexMatcherReference } from "./shared.js";
let StructureNode = (() => {
    let _classSuper = BaseConstraint;
    let _instanceExtraInitializers = [];
    let _keyof_decorators;
    return class StructureNode extends _classSuper {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _keyof_decorators = [cached];
            __esDecorate(this, null, _keyof_decorators, { kind: "method", name: "keyof", static: false, private: false, access: { has: obj => "keyof" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), this.$.keywords.object.raw);
        impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);
        props = this.required ?
            this.optional ?
                [...this.required, ...this.optional]
                : this.required
            : this.optional ?? [];
        propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);
        propsByKeyReference = registeredReference(this.propsByKey);
        expression = structuralExpression(this);
        requiredLiteralKeys = this.required?.map(node => node.key) ?? [];
        optionalLiteralKeys = this.optional?.map(node => node.key) ?? [];
        literalKeys = [
            ...this.requiredLiteralKeys,
            ...this.optionalLiteralKeys
        ];
        keyof() {
            let branches = this.$.units(this.literalKeys).branches;
            this.index?.forEach(({ signature: index }) => {
                branches = branches.concat(index.branches);
            });
            return this.$.node("union", branches);
        }
        exhaustive = this.undeclared !== undefined || this.index !== undefined;
        omit(...keys) {
            return this.$.node("structure", omitFromInner(this.inner, keys));
        }
        merge(r) {
            const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));
            if (r.required)
                inner.required = append(inner.required, r.required);
            if (r.optional)
                inner.optional = append(inner.optional, r.optional);
            if (r.index)
                inner.index = append(inner.index, r.index);
            if (r.sequence)
                inner.sequence = r.sequence;
            if (r.undeclared)
                inner.undeclared = r.undeclared;
            else
                delete inner.undeclared;
            return this.$.node("structure", inner);
        }
        traverseAllows = (data, ctx) => this._traverse("Allows", data, ctx);
        traverseApply = (data, ctx) => this._traverse("Apply", data, ctx);
        _traverse = (traversalKind, data, ctx) => {
            const errorCount = ctx?.currentErrorCount ?? 0;
            for (let i = 0; i < this.props.length; i++) {
                if (traversalKind === "Allows") {
                    if (!this.props[i].traverseAllows(data, ctx))
                        return false;
                }
                else {
                    this.props[i].traverseApply(data, ctx);
                    if (ctx.failFast && ctx.currentErrorCount > errorCount)
                        return false;
                }
            }
            if (this.sequence) {
                if (traversalKind === "Allows") {
                    if (!this.sequence.traverseAllows(data, ctx))
                        return false;
                }
                else {
                    this.sequence.traverseApply(data, ctx);
                    if (ctx.failFast && ctx.currentErrorCount > errorCount)
                        return false;
                }
            }
            if (!this.exhaustive)
                return true;
            const keys = Object.keys(data);
            keys.push(...Object.getOwnPropertySymbols(data));
            for (let i = 0; i < keys.length; i++) {
                const k = keys[i];
                let matched = false;
                if (this.index) {
                    for (const node of this.index) {
                        if (node.signature.traverseAllows(k, ctx)) {
                            if (traversalKind === "Allows") {
                                ctx?.path.push(k);
                                const result = node.value.traverseAllows(data[k], ctx);
                                ctx?.path.pop();
                                if (!result)
                                    return false;
                            }
                            else {
                                ctx.path.push(k);
                                node.value.traverseApply(data[k], ctx);
                                ctx.path.pop();
                                if (ctx.failFast && ctx.currentErrorCount > errorCount)
                                    return false;
                            }
                            matched = true;
                        }
                    }
                }
                if (this.undeclared) {
                    matched ||= k in this.propsByKey;
                    matched ||=
                        this.sequence !== undefined &&
                            typeof k === "string" &&
                            arrayIndexMatcher.test(k);
                    if (!matched) {
                        if (traversalKind === "Allows")
                            return false;
                        if (this.undeclared === "reject")
                            ctx.error({ expected: "removed", actual: null, relativePath: [k] });
                        else {
                            ctx.queueMorphs([
                                data => {
                                    delete data[k];
                                    return data;
                                }
                            ]);
                        }
                        if (ctx.failFast)
                            return false;
                    }
                }
                ctx?.path.pop();
            }
            return true;
        };
        compile(js) {
            if (js.traversalKind === "Apply")
                js.initializeErrorCount();
            this.props.forEach(prop => {
                js.check(prop);
                if (js.traversalKind === "Apply")
                    js.returnIfFailFast();
            });
            if (this.sequence) {
                js.check(this.sequence);
                if (js.traversalKind === "Apply")
                    js.returnIfFailFast();
            }
            if (this.exhaustive) {
                js.const("keys", "Object.keys(data)");
                js.line("keys.push(...Object.getOwnPropertySymbols(data))");
                js.for("i < keys.length", () => this.compileExhaustiveEntry(js));
            }
            if (js.traversalKind === "Allows")
                js.return(true);
        }
        compileExhaustiveEntry(js) {
            js.const("k", "keys[i]");
            if (this.undeclared)
                js.let("matched", false);
            this.index?.forEach(node => {
                js.if(`${js.invoke(node.signature, { arg: "k", kind: "Allows" })}`, () => {
                    js.traverseKey("k", "data[k]", node.value);
                    if (this.undeclared)
                        js.set("matched", true);
                    return js;
                });
            });
            if (this.undeclared) {
                if (this.props?.length !== 0)
                    js.line(`matched ||= k in ${this.propsByKeyReference}`);
                if (this.sequence) {
                    js.line(`matched ||= typeof k === "string" && ${arrayIndexMatcherReference}.test(k)`);
                }
                js.if("!matched", () => {
                    if (js.traversalKind === "Allows")
                        return js.return(false);
                    return this.undeclared === "reject" ?
                        js
                            .line(`ctx.error({ expected: "removed", actual: null, relativePath: [k] })`)
                            .if("ctx.failFast", () => js.return())
                        : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);
                });
            }
            return js;
        }
    };
})();
export { StructureNode };
const omitFromInner = (inner, keys) => {
    const result = { ...inner };
    keys.forEach(k => {
        if (result.required) {
            result.required = result.required.filter(b => typeof k === "function" ? !k.allows(b.key) : k !== b.key);
        }
        if (result.optional) {
            result.optional = result.optional.filter(b => typeof k === "function" ? !k.allows(b.key) : k !== b.key);
        }
        if (result.index && typeof k === "function") {
            // we only have to filter index nodes if the input was a node, as
            // literal keys should never subsume an index
            result.index = result.index.filter(n => !n.signature.extends(k));
        }
    });
    return result;
};
const createStructuralWriter = (childStringProp) => (node) => {
    if (node.props.length || node.index) {
        const parts = node.index?.map(String) ?? [];
        node.props.forEach(node => parts.push(node[childStringProp]));
        if (node.undeclared)
            parts.push(`+ (undeclared): ${node.undeclared}`);
        const objectLiteralDescription = `{ ${parts.join(", ")} }`;
        return node.sequence ?
            `${objectLiteralDescription} & ${node.sequence.description}`
            : objectLiteralDescription;
    }
    return node.sequence?.description ?? "{}";
};
const structuralDescription = createStructuralWriter("description");
const structuralExpression = createStructuralWriter("expression");
export const structureImplementation = implementNode({
    kind: "structure",
    hasAssociatedError: false,
    normalize: schema => schema,
    keys: {
        required: {
            child: true,
            parse: constraintKeyParser("required")
        },
        optional: {
            child: true,
            parse: constraintKeyParser("optional")
        },
        index: {
            child: true,
            parse: constraintKeyParser("index")
        },
        sequence: {
            child: true,
            parse: constraintKeyParser("sequence")
        },
        undeclared: {
            parse: behavior => (behavior === "ignore" ? undefined : behavior)
        }
    },
    defaults: {
        description: structuralDescription
    },
    intersections: {
        structure: (l, r, ctx) => {
            const lInner = { ...l.inner };
            const rInner = { ...r.inner };
            if (l.undeclared) {
                const lKey = l.keyof();
                const disjointRKeys = r.requiredLiteralKeys.filter(k => !lKey.allows(k));
                if (disjointRKeys.length) {
                    return Disjoint.from("presence", ctx.$.keywords.never.raw, r.propsByKey[disjointRKeys[0]].value).withPrefixKey(disjointRKeys[0]);
                }
                if (rInner.optional)
                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));
                if (rInner.index) {
                    rInner.index = rInner.index.flatMap(n => {
                        if (n.signature.extends(lKey))
                            return n;
                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);
                        if (indexOverlap instanceof Disjoint)
                            return [];
                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
                        if (normalized.required) {
                            rInner.required =
                                rInner.required ?
                                    [...rInner.required, ...normalized.required]
                                    : normalized.required;
                        }
                        return normalized.index ?? [];
                    });
                }
            }
            if (r.undeclared) {
                const rKey = r.keyof();
                const disjointLKeys = l.requiredLiteralKeys.filter(k => !rKey.allows(k));
                if (disjointLKeys.length) {
                    return Disjoint.from("presence", l.propsByKey[disjointLKeys[0]].value, ctx.$.keywords.never.raw).withPrefixKey(disjointLKeys[0]);
                }
                if (lInner.optional)
                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));
                if (lInner.index) {
                    lInner.index = lInner.index.flatMap(n => {
                        if (n.signature.extends(rKey))
                            return n;
                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);
                        if (indexOverlap instanceof Disjoint)
                            return [];
                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
                        if (normalized.required) {
                            lInner.required =
                                lInner.required ?
                                    [...lInner.required, ...normalized.required]
                                    : normalized.required;
                        }
                        return normalized.index ?? [];
                    });
                }
            }
            const baseInner = {};
            if (l.undeclared || r.undeclared) {
                baseInner.undeclared =
                    l.undeclared === "reject" || r.undeclared === "reject" ?
                        "reject"
                        : "delete";
            }
            return intersectConstraints({
                kind: "structure",
                baseInner,
                l: flattenConstraints(lInner),
                r: flattenConstraints(rInner),
                roots: [],
                ctx
            });
        }
    }
});
/** extract enumerable named props from an index signature */
export const normalizeIndex = (signature, value, $) => {
    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, (k) => k.hasKind("unit"));
    if (!enumerableBranches.length)
        return { index: $.node("index", { signature, value }) };
    const normalized = {};
    normalized.required = enumerableBranches.map(n => $.node("required", { key: n.unit, value }));
    if (nonEnumerableBranches.length) {
        normalized.index = $.node("index", {
            signature: nonEnumerableBranches,
            value
        });
    }
    return normalized;
};
