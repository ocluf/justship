import { BaseConstraint } from "../constraint.js";
import type { Node, RootSchema } from "../kinds.js";
import type { DeepNodeTransformation, DeepNodeTransformationContext } from "../node.js";
import type { BaseRoot } from "../roots/root.js";
import type { BaseMeta, declareNode } from "../shared/declare.js";
import { type RootKind, type nodeImplementationOf } from "../shared/implement.js";
import type { TraverseAllows, TraverseApply } from "../shared/traversal.js";
export type IndexKeyKind = Exclude<RootKind, "unit">;
export type IndexKeyNode = Node<IndexKeyKind>;
export interface IndexSchema extends BaseMeta {
    readonly signature: RootSchema<IndexKeyKind>;
    readonly value: RootSchema;
}
export interface IndexInner extends BaseMeta {
    readonly signature: IndexKeyNode;
    readonly value: BaseRoot;
}
export interface IndexDeclaration extends declareNode<{
    kind: "index";
    schema: IndexSchema;
    normalizedSchema: IndexSchema;
    inner: IndexInner;
    prerequisite: object;
    intersectionIsOpen: true;
    childKind: RootKind;
}> {
}
export declare const indexImplementation: nodeImplementationOf<IndexDeclaration>;
export declare class IndexNode extends BaseConstraint<IndexDeclaration> {
    impliedBasis: BaseRoot;
    expression: string;
    traverseAllows: TraverseAllows<object>;
    traverseApply: TraverseApply<object>;
    protected _transform(mapper: DeepNodeTransformation, ctx: DeepNodeTransformationContext): import("../node.js").BaseNode<import("../shared/declare.js").RawNodeDeclaration> | null;
    compile(): void;
}
export declare const writeEnumerableIndexBranches: (keys: string[]) => string;
export declare const writeInvalidPropertyKeyMessage: <indexSchema extends string>(indexSchema: indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;
export type writeInvalidPropertyKeyMessage<indexSchema extends string> = `Indexed key definition '${indexSchema}' must be a string, number or symbol`;
