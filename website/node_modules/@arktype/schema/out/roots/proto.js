import { builtinConstructors, constructorExtends, getExactBuiltinConstructorName, objectKindDescriptions, objectKindOrDomainOf, prototypeKeysOf } from "@arktype/util";
import { Disjoint } from "../shared/disjoint.js";
import { defaultValueSerializer, implementNode } from "../shared/implement.js";
import { RawBasis } from "./basis.js";
export const protoImplementation = implementNode({
    kind: "proto",
    hasAssociatedError: true,
    collapsibleKey: "proto",
    keys: {
        proto: {
            serialize: ctor => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)
        }
    },
    normalize: schema => typeof schema === "string" ? { proto: builtinConstructors[schema] }
        : typeof schema === "function" ? { proto: schema }
            : typeof schema.proto === "string" ?
                { ...schema, proto: builtinConstructors[schema.proto] }
                : schema,
    defaults: {
        description: node => node.builtinName ?
            objectKindDescriptions[node.builtinName]
            : `an instance of ${node.proto.name}`,
        actual: data => objectKindOrDomainOf(data)
    },
    intersections: {
        proto: (l, r) => constructorExtends(l.proto, r.proto) ? l
            : constructorExtends(r.proto, l.proto) ? r
                : Disjoint.from("proto", l, r),
        domain: (proto, domain, ctx) => domain.domain === "object" ?
            proto
            : Disjoint.from("domain", ctx.$.keywords.object.raw, domain)
    }
});
export class ProtoNode extends RawBasis {
    builtinName = getExactBuiltinConstructorName(this.proto);
    serializedConstructor = this.json.proto;
    compiledCondition = `data instanceof ${this.serializedConstructor}`;
    compiledNegation = `!(${this.compiledCondition})`;
    literalKeys = prototypeKeysOf(this.proto.prototype);
    traverseAllows = data => data instanceof this.proto;
    expression = this.proto.name;
    domain = "object";
}
