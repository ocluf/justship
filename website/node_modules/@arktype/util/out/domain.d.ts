import type { show } from "./generics.js";
import type { stringifyUnion } from "./unionToTuple.js";
export declare const hasDomain: <data, domain extends Domain>(data: data, kind: domain) => data is data & inferDomain<domain>;
type TypesByDomain = {
    bigint: bigint;
    boolean: boolean;
    number: number;
    object: object;
    string: string;
    symbol: symbol;
    undefined: undefined;
    null: null;
};
export type inferDomain<kind extends Domain> = Domain extends kind ? unknown : TypesByDomain[kind];
export type Domain = show<keyof TypesByDomain>;
export type NullishDomain = "undefined" | "null";
export type NonNullishDomain = Exclude<Domain, NullishDomain>;
export type PrimitiveDomain = Exclude<Domain, "object">;
export type Primitive = inferDomain<PrimitiveDomain>;
export type domainOf<data> = unknown extends data ? Domain : data extends object ? "object" : data extends string ? "string" : data extends number ? "number" : data extends boolean ? "boolean" : data extends undefined ? "undefined" : data extends null ? "null" : data extends bigint ? "bigint" : data extends symbol ? "symbol" : never;
export declare const domainOf: <data>(data: data) => domainOf<data>;
declare const nonEnumerableDomainDescriptions: {
    readonly bigint: "a bigint";
    readonly number: "a number";
    readonly object: "an object";
    readonly string: "a string";
    readonly symbol: "a symbol";
};
export type NonEnumerableDomain = keyof typeof nonEnumerableDomainDescriptions;
/** Each domain's completion for the phrase "must be _____" */
export declare const domainDescriptions: {
    boolean: "boolean";
    null: "null";
    undefined: "undefined";
    bigint: "a bigint";
    number: "a number";
    object: "an object";
    string: "a string";
    symbol: "a symbol";
};
export type domainDescriptions = typeof domainDescriptions;
export type describeDomainOf<t> = stringifyUnion<domainDescriptions[domainOf<t>], " or ">;
export {};
