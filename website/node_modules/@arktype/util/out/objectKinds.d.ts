import type { array } from "./arrays.js";
import { type Domain, type domainDescriptions, domainOf } from "./domain.js";
import { type Key } from "./records.js";
export type builtinConstructors = {
    Array: ArrayConstructor;
    Date: DateConstructor;
    Error: ErrorConstructor;
    Function: FunctionConstructor;
    Map: MapConstructor;
    RegExp: RegExpConstructor;
    Set: SetConstructor;
    String: StringConstructor;
    Number: NumberConstructor;
    Boolean: BooleanConstructor;
    WeakMap: WeakMapConstructor;
    WeakSet: WeakSetConstructor;
    Promise: PromiseConstructor;
};
export declare const builtinConstructors: builtinConstructors;
export type BuiltinObjectConstructors = typeof builtinConstructors;
export type BuiltinObjectKind = keyof BuiltinObjectConstructors;
export type BuiltinObjects = {
    [kind in BuiltinObjectKind]: InstanceType<BuiltinObjectConstructors[kind]>;
};
export type objectKindOf<data extends object> = object extends data ? keyof builtinConstructors | undefined : data extends (...args: never[]) => unknown ? "Function" : instantiableObjectKind<data> extends never ? keyof builtinConstructors | undefined : instantiableObjectKind<data>;
export type describeObject<o extends object> = objectKindOf<o> extends string ? objectKindDescriptions[objectKindOf<o>] : domainDescriptions["object"];
type instantiableObjectKind<data extends object> = {
    [kind in keyof builtinConstructors]: data extends (InstanceType<builtinConstructors[kind]>) ? kind : never;
}[keyof builtinConstructors];
export declare const objectKindOf: <data extends object>(data: data) => objectKindOf<data> | undefined;
export declare const objectKindOrDomainOf: <data>(data: data) => (objectKindOf<data & object> & {}) | domainOf<data>;
export type objectKindOrDomainOf<data> = data extends object ? objectKindOf<data> extends undefined ? "object" : objectKindOf<data> : domainOf<data>;
export declare const hasObjectKind: <kind extends keyof builtinConstructors>(data: object, kind: kind) => data is InstanceType<builtinConstructors[kind]>;
export declare const isArray: (data: unknown) => data is array;
/** Each defaultObjectKind's completion for the phrase "must be _____" */
export declare const objectKindDescriptions: {
    readonly Array: "an array";
    readonly Function: "a function";
    readonly Date: "a Date";
    readonly RegExp: "a RegExp";
    readonly Error: "an Error";
    readonly Map: "a Map";
    readonly Set: "a Set";
    readonly String: "a String object";
    readonly Number: "a Number object";
    readonly Boolean: "a Boolean object";
    readonly Promise: "a Promise";
    readonly WeakMap: "a WeakMap";
    readonly WeakSet: "a WeakSet";
};
export type objectKindDescriptions = typeof objectKindDescriptions;
export declare const getExactBuiltinConstructorName: (ctor: unknown) => BuiltinObjectKind | null;
export type Constructor<instance = {}> = abstract new (...args: never[]) => instance;
export type instanceOf<constructor> = constructor extends Constructor<infer instance> ? instance : never;
/**
 * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.
 *
 * @param {object} o - The object to find the ancestors of.
 * @returns {Function[]} An array of constructors for all ancestors of the object.
 */
export declare const ancestorsOf: (o: object) => Function[];
export type normalizedKeyOf<t> = keyof t extends infer k ? k extends number ? `${k}` : k : never;
/** Mimics output of TS's keyof operator at runtime */
export declare const prototypeKeysOf: <t>(value: t) => normalizedKeyOf<t>[];
export declare const getBaseDomainKeys: <domain extends Domain>(domain: domain) => Key[];
export declare const constructorExtends: (ctor: Constructor, base: Constructor) => boolean;
export {};
