import { NoopBase } from "./records.js";
export declare const bound: (target: Function, ctx: ClassMemberDecoratorContext) => void;
export declare const cached: <self>(target: (this: self) => any, context: ClassGetterDecoratorContext<self, any> | ClassMethodDecoratorContext<self, (this: self) => any>) => (this: self) => any;
export declare const cachedThunk: <t>(thunk: () => t) => (() => t);
export declare const isThunk: <value>(value: value) => value is Extract<value, Thunk<unknown>> extends never ? value & Thunk<unknown> : Extract<value, Thunk<unknown>>;
export type Thunk<ret = unknown> = () => ret;
export type thunkable<t> = t | Thunk<t>;
export declare const tryCatch: <returns, onError = never>(fn: () => returns, onError?: ((e: unknown) => onError) | undefined) => returns | onError;
export declare const DynamicFunction: DynamicFunction;
export type DynamicFunction = new <f extends (...args: never[]) => unknown>(...args: ConstructorParameters<typeof Function>) => f & {
    apply(thisArg: null, args: Parameters<f>): ReturnType<f>;
    call(thisArg: null, ...args: Parameters<f>): ReturnType<f>;
};
export type CallableOptions<attachments extends object> = {
    attach?: attachments;
    bind?: object;
};
/** @ts-expect-error required to cast function type */
export declare class Callable<f extends (...args: never[]) => unknown, attachments extends object = {}> extends NoopBase<f & attachments> {
    constructor(f: f, opts?: CallableOptions<attachments>);
}
export type Guardable<input = unknown, narrowed extends input = input> = ((In: input) => In is narrowed) | ((In: input) => boolean);
/**
 * Checks if the environment has Content Security Policy (CSP) enabled,
 * preventing JIT-optimized code from being compiled via new Function().
 *
 * @returns `true` if a function created using new Function() can be
 * successfully invoked in the environment, `false` otherwise.
 *
 * The result is cached for subsequent invocations.
 */
export declare const envHasCsp: () => boolean;
